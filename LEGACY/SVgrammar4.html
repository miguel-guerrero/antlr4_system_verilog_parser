<html>

<head>
</head>

<body>

<p> // A.1 Source text</p>

<p> // A.1.1 Library source text</p>

<p>library_text ::= { library_description }</p>

<p>library_description ::= library_declaration</p>

<p>| include_statement | config_declaration |<span
style='color:red'>;</span></p>

<p>library_declaration ::=</p>

<p><span style='color:red'>library </span>library_identifier
file_path_spec { <span style='color:red'>, </span>file_path_spec }</p>

<p>[ <span style='color:red'>-incdir </span>file_path_spec
{ <span style='color:red'>, </span>file_path_spec } ] <span
style='color:red'>; </span>include_statement ::= <span style='color:red'>include
</span>file_path_spec <span style='color:red'>;</span></p>

<p> // A.1.2 SystemVerilog source text</p>

<p>source_text ::= [ timeunits_declaration ] { description }</p>

<p>description ::= module_declaration</p>

<p>| udp_declaration</p>

<p>| interface_declaration</p>

<p>| program_declaration</p>

 

 

<p>  </p>

 

<p>| package_declaration</p>

<p>| { attribute_instance } package_item | { attribute_instance
} bind_directive | config_declaration</p>

<p>module_nonansi_header ::=</p>

<p>{ attribute_instance } module_keyword [ lifetime ]
module_identifier</p>

<p>{ package_import_declaration } [ parameter_port_list ]
list_of_ports <span style='color:red'>; </span>module_ansi_header ::=</p>

<p>{ attribute_instance } module_keyword [ lifetime ]
module_identifier</p>

<p>{ package_import_declaration }<span style='color:blue;
position:relative;top:-4.0pt'>1 </span>[ parameter_port_list ] [
list_of_port_declarations ] <span style='color:red'>;</span></p>

<p>module_declaration ::=</p>

<p>module_nonansi_header [ timeunits_declaration ] {
module_item }</p>

<p><span style='color:red'>endmodule </span>[ <span
style='color:red'>: </span>module_identifier ]</p>

<p>| module_ansi_header [ timeunits_declaration ] { non_port_module_item
}</p>

<p><span style='color:red'>endmodule </span>[ <span
style='color:red'>: </span>module_identifier ]</p>

<p>| { attribute_instance } module_keyword [ lifetime ]
module_identifier <span style='color:red'>( .* ) ;</span></p>

<p>[ timeunits_declaration ] { module_item } <span
style='color:red'>endmodule </span>[ <span style='color:red'>: </span>module_identifier
]</p>

<p>| <span style='color:red'>extern </span>module_nonansi_header</p>

<p>| <span style='color:red'>extern </span>module_ansi_header</p>

<p>module_keyword ::= <span style='color:red'>module </span>|
<span style='color:red'>macromodule</span></p>

<p>interface_declaration ::=</p>

<p>interface_nonansi_header [ timeunits_declaration ] {
interface_item }</p>

<p><span style='color:red'>endinterface </span>[ <span
style='color:red'>: </span>interface_identifier ]</p>

<p>| interface_ansi_header [ timeunits_declaration ] {
non_port_interface_item }</p>

<p><span style='color:red'>endinterface </span>[ <span
style='color:red'>: </span>interface_identifier ]</p>

<p>| { attribute_instance } <span style='color:red'>interface
</span>interface_identifier <span style='color:red'>( .* ) ;</span></p>

<p>[ timeunits_declaration ] { interface_item } <span
style='color:red'>endinterface </span>[ <span style='color:red'>: </span>interface_identifier
]</p>

<p>| <span style='color:red'>extern </span>interface_nonansi_header</p>

<p>| <span style='color:red'>extern </span>interface_ansi_header</p>

<p>interface_nonansi_header ::=</p>

<p>{ attribute_instance } <span style='color:red'>interface
</span>[ lifetime ] interface_identifier</p>

<p>{ package_import_declaration } [ parameter_port_list ]
list_of_ports <span style='color:red'>; </span>interface_ansi_header ::=</p>

<p>{attribute_instance } <span style='color:red'>interface </span>[
lifetime ] interface_identifier</p>

<p>{ package_import_declaration }<span style='color:blue;
position:relative;top:-4.0pt'>1 </span>[ parameter_port_list ] [
list_of_port_declarations ] <span style='color:red'>;</span></p>

<p>program_declaration ::=</p>

<p>program_nonansi_header [ timeunits_declaration ] {
program_item }</p>

<p><span style='color:red'>endprogram </span>[ <span
style='color:red'>: </span>program_identifier ]</p>

<p>| program_ansi_header [ timeunits_declaration ] {
non_port_program_item }</p>

<p><span style='color:red'>endprogram </span>[ <span
style='color:red'>: </span>program_identifier ]</p>

<p>| { attribute_instance } <span style='color:red'>program
</span>program_identifier <span style='color:red'>( .* ) ;</span></p>

<p>[ timeunits_declaration ] { program_item } <span
style='color:red'>endprogram </span>[ <span style='color:red'>: </span>program_identifier
]</p>

<p>| <span style='color:red'>extern </span>program_nonansi_header</p>

<p>| <span style='color:red'>extern </span>program_ansi_header</p>

<p>program_nonansi_header ::=</p>

<p>{ attribute_instance } <span style='color:red'>program </span>[
lifetime ] program_identifier</p>

<p>{ package_import_declaration } [ parameter_port_list ]
list_of_ports <span style='color:red'>; </span>program_ansi_header ::=</p>

<p>{attribute_instance } <span style='color:red'>program </span>[
lifetime ] program_identifier  </p>

 

<p>   </p>

 

 

<p>{ package_import_declaration }<span style='color:blue;
position:relative;top:-4.0pt'>1 </span>[ parameter_port_list ] [
list_of_port_declarations ] <span style='color:red'>;</span></p>

<p>checker_declaration ::=</p>

<p><span style='color:red'>checker </span>checker_identifier
[ <span style='color:red'>( </span>[ checker_port_list ] <span
style='color:red'>) </span>] <span style='color:red'>;</span></p>

<p>{ { attribute_instance } checker_or_generate_item } <span
style='color:red'>endchecker </span>[ <span style='color:red'>: </span>checker_identifier
]</p>

<p>class_declaration ::=</p>

<p>[ <span style='color:red'>virtual </span>] <span
style='color:red'>class </span>[ lifetime ] class_identifier [
parameter_port_list ]</p>

<p>[ <span style='color:red'>extends </span>class_type [ <span
style='color:red'>( </span>list_of_arguments <span style='color:red'>) </span>]
]</p>

<p>[ <span style='color:red'>implements </span>interface_class_type
{ <span style='color:red'>, </span>interface_class_type } ] <span
style='color:red'>; </span>{ class_item }</p>

<p><span style='color:red'>endclass </span>[ <span
style='color:red'>: </span>class_identifier]</p>

<p>interface_class_type ::= ps_class_identifier [
parameter_value_assignment ]</p>

<p>interface_class_declaration ::=</p>

<p><span style='color:red'>interface class </span>class_identifier
[ parameter_port_list ]</p>

<p>[ <span style='color:red'>extends </span>interface_class_type
{ <span style='color:red'>, </span>interface_class_type } ] <span
style='color:red'>;</span></p>

<p>{ interface_class_item } <span style='color:red'>endclass
</span>[ <span style='color:red'>: </span>class_identifier]</p>

<p>interface_class_item ::= type_declaration</p>

<p>| { attribute_instance } interface_class_method</p>

<p>| local_parameter_declaration <span style='color:red'>;</span></p>

<p>| parameter_declaration<span style='color:blue;position:
relative;top:-4.0pt'>7 </span><span style='color:red'>; </span>|<span
style='color:red'>;</span></p>

<p>interface_class_method ::=</p>

<p><span style='color:red'>pure virtual </span>method_prototype
<span style='color:red'>;</span></p>

<p>package_declaration ::=</p>

<p>{ attribute_instance } <span style='color:red'>package </span>[
lifetime ] package_identifier <span style='color:red'>;</span></p>

<p>[ timeunits_declaration ] { { attribute_instance }
package_item } <span style='color:red'>endpackage </span>[ <span
style='color:red'>: </span>package_identifier ]</p>

<p>timeunits_declaration ::=</p>

<p><span style='color:red'>timeunit </span>time_literal [ <span
style='color:red'>/ </span>time_literal ] <span style='color:red'>;</span></p>

<p>| <span style='color:red'>timeprecision </span>time_literal
<span style='color:red'>;</span></p>

<p>| <span style='color:red'>timeunit </span>time_literal <span
style='color:red'>; timeprecision </span>time_literal <span
style='color:red'>; </span>| <span style='color:red'>timeprecision </span>time_literal
<span style='color:red'>; timeunit </span>time_literal <span
style='color:red'>;</span></p>

<p> // A.1.3 Module parameters and ports</p>

<p>parameter_port_list ::=</p>

<p><span style='color:red'># (</span>list_of_param_assignments{<span
style='color:red'>,</span>parameter_port_declaration}<span
style='color:red'>)</span></p>

<p>| <span style='color:red'># ( </span>parameter_port_declaration
{ <span style='color:red'>, </span>parameter_port_declaration } <span
style='color:red'>) </span>| <span style='color:red'>#( )</span></p>

<p>parameter_port_declaration ::= parameter_declaration</p>

<p>| local_parameter_declaration</p>

<p>| data_type list_of_param_assignments</p>

<p>| <span style='color:red'>type </span>list_of_type_assignments</p>

<p>list_of_ports ::= <span style='color:red'>( </span>port
{ <span style='color:red'>, </span>port } <span style='color:red'>) </span>list_of_port_declarations<span
style='color:blue;position:relative;top:-4.0pt'>2 </span>::=</p>

<p><span style='color:red'>( </span>[ { attribute_instance}
ansi_port_declaration { <span style='color:red'>, </span>{
attribute_instance} ansi_port_declaration } ] <span style='color:red'>) </span> </p>

 

<p>    </p>

 

 

<p>port_declaration ::=</p>

<p>{ attribute_instance } inout_declaration</p>

<p>| { attribute_instance } input_declaration</p>

<p>| { attribute_instance } output_declaration</p>

<p>| { attribute_instance } ref_declaration</p>

<p>| { attribute_instance } interface_port_declaration</p>

<p>port ::=</p>

<p>[ port_expression ]</p>

<p>| <span style='color:red'>. </span>port_identifier <span
style='color:red'>( </span>[ port_expression ] <span style='color:red'>)</span></p>

<p>port_expression ::= port_reference</p>

<p>| <span style='color:red'>{ </span>port_reference { <span
style='color:red'>, </span>port_reference } <span style='color:red'>} </span>port_reference
::=</p>

<p>port_identifier constant_select</p>

<p>port_direction ::= <span style='color:red'>input </span>|
<span style='color:red'>output </span>| <span style='color:red'>inout </span>|
<span style='color:red'>ref </span>net_port_header ::= [ port_direction ]
net_port_type variable_port_header ::= [ port_direction ] variable_port_type</p>

<p>interface_port_header ::=</p>

<p>interface_identifier [ <span style='color:red'>. </span>modport_identifier
]</p>

<p>| <span style='color:red'>interface </span>[ <span
style='color:red'>. </span>modport_identifier ]</p>

<p>ansi_port_declaration ::=</p>

<p>[ net_port_header | interface_port_header ] port_identifier
{ unpacked_dimension }</p>

<p>[ <span style='color:red'>= </span>constant_expression ]</p>

<p>| [ variable_port_header ] port_identifier {
variable_dimension } [ <span style='color:red'>= </span>constant_expression
]</p>

<p>| [ port_direction ] <span style='color:red'>. </span>port_identifier
<span style='color:red'>( </span>[ expression ] <span style='color:red'>)</span></p>

<p> // A.1.4 Module items</p>

<p>elaboration_system_task ::=</p>

<p><span style='color:red'>$fatal </span>[ <span
style='color:red'>( </span>finish_number [<span style='color:red'>, </span>list_of_arguments
] <span style='color:red'>) </span>] <span style='color:red'>;</span></p>

<p>| <span style='color:red'>$error </span>[ <span
style='color:red'>( </span>[ list_of_arguments ] <span style='color:red'>)
</span>] <span style='color:red'>;</span></p>

<p>| <span style='color:red'>$warning </span>[ <span
style='color:red'>( </span>[ list_of_arguments ] <span style='color:red'>)
</span>] <span style='color:red'>; </span>| <span style='color:red'>$info
</span>[ <span style='color:red'>( </span>[ list_of_arguments ] <span
style='color:red'>) </span>] <span style='color:red'>;</span></p>

<p>finish_number ::= <span style='color:red'>0 </span>| <span
style='color:red'>1 </span>| <span style='color:red'>2</span></p>

<p>module_common_item ::= module_or_generate_item_declaration</p>

<p>| interface_instantiation</p>

<p>| program_instantiation</p>

<p>| assertion_item</p>

<p>| bind_directive</p>

<p>| continuous_assign</p>

<p>| net_alias</p>

<p>| initial_construct</p>

<p>| final_construct</p>

<p>| always_construct</p>

<p>| loop_generate_construct</p>

<p>| conditional_generate_construct</p>

<p>| elaboration_system_task</p>

<p>module_item ::= port_declaration <span style='color:red'>;</span></p>

 

 

 

 

 

<p>| non_port_module_item</p>

<p>module_or_generate_item ::=</p>

<p>{ attribute_instance } parameter_override</p>

<p>| { attribute_instance } gate_instantiation</p>

<p>| { attribute_instance } udp_instantiation</p>

<p>| { attribute_instance } module_instantiation</p>

<p>| { attribute_instance } module_common_item</p>

<p>module_or_generate_item_declaration ::=
package_or_generate_item_declaration</p>

<p>| genvar_declaration</p>

<p>| clocking_declaration</p>

<p>| <span style='color:red'>default clocking </span>clocking_identifier
<span style='color:red'>;</span></p>

<p>| <span style='color:red'>default disable iff </span>expression_or_dist
<span style='color:red'>;</span></p>

<p>non_port_module_item ::= generate_region</p>

<p>| module_or_generate_item</p>

<p>| specify_block</p>

<p>| { attribute_instance } specparam_declaration</p>

<p>| program_declaration</p>

<p>| module_declaration</p>

<p>| interface_declaration</p>

<p>| timeunits_declaration<span style='color:blue;position:
relative;top:-4.0pt'>3</span></p>

<p>parameter_override ::= <span style='color:red'>defparam </span>list_of_defparam_assignments
<span style='color:red'>;</span></p>

<p>bind_directive<span style='color:blue;position:relative;
top:-4.0pt'>4 </span>::=</p>

<p><span style='color:red'>bind </span>bind_target_scope [<span
style='color:red'>: </span>bind_target_instance_list] bind_instantiation <span
style='color:red'>;</span></p>

<p>| <span style='color:red'>bind </span>bind_target_instance
bind_instantiation <span style='color:red'>;</span></p>

<p>bind_target_scope ::= module_identifier</p>

<p>| interface_identifier</p>

<p>bind_target_instance ::= hierarchical_identifier
constant_bit_select</p>

<p>bind_target_instance_list ::=</p>

<p>bind_target_instance { <span style='color:red'>, </span>bind_target_instance
}</p>

<p>bind_instantiation ::= program_instantiation</p>

<p>| module_instantiation</p>

<p>| interface_instantiation</p>

<p>| checker_instantiation</p>

<p> // A.1.5 Configuration source text</p>

<p>config_declaration ::=</p>

<p><span style='color:red'>config </span>config_identifier <span
style='color:red'>;</span></p>

<p>{ local_parameter_declaration <span style='color:red'>; </span>}
design_statement</p>

<p>{ config_rule_statement }</p>

<p><span style='color:red'>endconfig </span>[ <span
style='color:red'>: </span>config_identifier ]</p>

<p>design_statement ::= <span style='color:red'>design </span>{
[ library_identifier <span style='color:red'>. </span>] cell_identifier } <span
style='color:red'>;</span></p>

<p>config_rule_statement ::= default_clause liblist_clause <span
style='color:red'>;</span></p>

 

 

<p>   </p>

 

 

<p>| inst_clause liblist_clause <span style='color:red'>; </span>|
inst_clause use_clause <span style='color:red'>;</span></p>

<p>| cell_clause liblist_clause <span style='color:red'>; </span>|
cell_clause use_clause <span style='color:red'>;</span></p>

<p>default_clause ::= <span style='color:red'>default</span></p>

<p>inst_clause ::= <span style='color:red'>instance </span>inst_name</p>

<p>inst_name ::= topmodule_identifier { <span style='color:
red'>. </span>instance_identifier } cell_clause::=<span style='color:red'>cell
</span>[library_identifier<span style='color:red'>. </span>]cell_identifier
liblist_clause ::= <span style='color:red'>liblist </span>{library_identifier}</p>

<p>use_clause ::= <span style='color:red'>use </span>[
library_identifier <span style='color:red'>. </span>] cell_identifier [ <span
style='color:red'>: config </span>]</p>

<p>| <span style='color:red'>use </span>named_parameter_assignment
{ <span style='color:red'>, </span>named_parameter_assignment } [ <span
style='color:red'>: config </span>] | <span style='color:red'>use </span>[
library_identifier <span style='color:red'>. </span>] cell_identifier
named_parameter_assignment</p>

<p>{ <span style='color:red'>, </span>named_parameter_assignment
} [ <span style='color:red'>: config </span>]  // A.1.6 Interface items</p>

<p>interface_or_generate_item ::=</p>

<p>{ attribute_instance } module_common_item</p>

<p>| { attribute_instance } extern_tf_declaration</p>

<p>extern_tf_declaration ::=</p>

<p><span style='color:red'>extern </span>method_prototype <span
style='color:red'>;</span></p>

<p>| <span style='color:red'>extern forkjoin </span>task_prototype
<span style='color:red'>;</span></p>

<p>interface_item ::= port_declaration <span style='color:red'>;</span></p>

<p>| non_port_interface_item</p>

<p>non_port_interface_item ::= generate_region</p>

<p>| interface_or_generate_item</p>

<p>| program_declaration</p>

<p>| modport_declaration</p>

<p>| interface_declaration</p>

<p>| timeunits_declaration<span style='color:blue;position:
relative;top:-4.0pt'>3 </span> // A.1.7 Program items</p>

<p>program_item ::= port_declaration <span style='color:red'>;</span></p>

<p>| non_port_program_item</p>

<p>non_port_program_item ::=</p>

<p>{ attribute_instance } continuous_assign</p>

<p>| { attribute_instance } module_or_generate_item_declaration</p>

<p>| { attribute_instance } initial_construct</p>

<p>| { attribute_instance } final_construct</p>

<p>| { attribute_instance } concurrent_assertion_item</p>

<p>  | timeunits_declaration<span style='color:blue;position:
relative;top:-4.0pt'>3</span></p>

<p>| program_generate_item</p>

<p>program_generate_item<span style='color:blue;position:relative;
top:-4.0pt'>5 </span>::= loop_generate_construct</p>

<p>| conditional_generate_construct</p>

<p>   </p>

 

 

 

 

<p>| generate_region</p>

<p>| elaboration_system_task</p>

<p> // A.1.8 Checker items</p>

<p>checker_port_list ::=</p>

<p>checker_port_item {<span style='color:red'>, </span>checker_port_item}</p>

<p>checker_port_item ::=</p>

<p>{ attribute_instance } [ checker_port_direction ]
property_formal_type formal_port_identifier</p>

<p>{variable_dimension} [ <span style='color:red'>= </span>property_actual_arg
] checker_port_direction ::=</p>

<p><span style='color:red'>input </span>| <span
style='color:red'>output</span></p>

<p>checker_or_generate_item ::=
checker_or_generate_item_declaration</p>

<p>| initial_construct</p>

<p>| always_construct</p>

<p>| final_construct</p>

<p>| assertion_item</p>

<p>| continuous_assign</p>

<p>| checker_generate_item</p>

<p>checker_or_generate_item_declaration ::= [ <span
style='color:red'>rand </span>] data_declaration</p>

<p>| function_declaration</p>

<p>| checker_declaration</p>

<p>| assertion_item_declaration</p>

<p>| covergroup_declaration</p>

<p>| genvar_declaration</p>

<p>| clocking_declaration</p>

<p>| <span style='color:red'>default clocking </span>clocking_identifier
<span style='color:red'>;</span></p>

<p>| <span style='color:red'>default disable iff </span>expression_or_dist
<span style='color:red'>; </span>|<span style='color:red'>;</span></p>

<p>checker_generate_item<span style='color:blue;position:relative;
top:-4.0pt'>6 </span>::= loop_generate_construct</p>

<p>| conditional_generate_construct</p>

<p>| generate_region</p>

<p>| elaboration_system_task</p>

<p> // A.1.9 Class items</p>

<p>class_item ::=</p>

<p>{ attribute_instance } class_property</p>

<p>| { attribute_instance } class_method</p>

<p>| { attribute_instance } class_constraint</p>

<p>| { attribute_instance } class_declaration</p>

<p>| { attribute_instance } covergroup_declaration</p>

<p>| local_parameter_declaration <span style='color:red'>;</span></p>

<p>| parameter_declaration<span style='color:blue;position:
relative;top:-4.0pt'>7 </span><span style='color:red'>; </span>|<span
style='color:red'>;</span></p>

<p>class_property ::=</p>

<p>{ property_qualifier } data_declaration</p>

<p>| <span style='color:red'>const </span>{
class_item_qualifier } data_type const_identifier [ <span style='color:red'>=
</span>constant_expression ] <span style='color:red'>; </span> </p>

 

<p>   </p>

 

 

<p>class_method ::=</p>

<p>{ method_qualifier } task_declaration</p>

<p>| { method_qualifier } function_declaration</p>

<p>| <span style='color:red'>pure virtual </span>{
class_item_qualifier } method_prototype <span style='color:red'>;</span></p>

<p>| <span style='color:red'>extern </span>{
method_qualifier } method_prototype <span style='color:red'>;</span></p>

<p>| { method_qualifier } class_constructor_declaration</p>

<p>| <span style='color:red'>extern </span>{
method_qualifier } class_constructor_prototype</p>

<p>class_constructor_prototype ::=</p>

<p><span style='color:red'>function new </span>[<span
style='color:red'>(</span>[tf_port_list]<span style='color:red'>)</span>]<span
style='color:red'>;</span></p>

<p>class_constraint ::= constraint_prototype</p>

<p>| constraint_declaration</p>

<p>class_item_qualifier<span style='color:blue;position:relative;
top:-4.0pt'>8 </span>::= <span style='color:red'>static</span></p>

<p>| <span style='color:red'>protected </span>| <span
style='color:red'>local</span></p>

<p>property_qualifier<span style='color:blue;position:relative;
top:-4.0pt'>8 </span>::= random_qualifier</p>

<p>| class_item_qualifier</p>

<p>random_qualifier<span style='color:blue;position:relative;
top:-4.0pt'>8 </span>::= <span style='color:red'>rand</span></p>

<p>| <span style='color:red'>randc</span></p>

<p>method_qualifier<span style='color:blue;position:relative;
top:-4.0pt'>8 </span>::=</p>

<p>[ <span style='color:red'>pure </span>] <span
style='color:red'>virtual</span></p>

<p>| class_item_qualifier</p>

<p>method_prototype ::= task_prototype</p>

<p>| function_prototype</p>

<p>class_constructor_declaration ::= <span style='color:red'>function</span>[class_scope]<span
style='color:red'>new</span>[<span style='color:red'>(</span>[tf_port_list]<span
style='color:red'>) </span>]<span style='color:red'>;</span></p>

<p>{ block_item_declaration }</p>

<p>[<span style='color:red'>super . new</span>[<span
style='color:red'>(</span>list_of_arguments<span style='color:red'>)</span>]<span
style='color:red'>;</span>] { function_statement_or_null }</p>

<p><span style='color:red'>endfunction </span>[ <span
style='color:red'>: new </span>]  // A.1.10 Constraints</p>

<p>constraint_declaration ::= [ <span style='color:red'>static
</span>] <span style='color:red'>constraint </span>constraint_identifier
constraint_block</p>

<p>constraint_block ::= <span style='color:red'>{ </span>{
constraint_block_item } <span style='color:red'>}</span></p>

<p>constraint_block_item ::=</p>

<p><span style='color:red'>solve </span>solve_before_list <span
style='color:red'>before </span>solve_before_list <span style='color:red'>;</span></p>

<p>| constraint_expression</p>

<p>solve_before_list ::= constraint_primary { <span
style='color:red'>, </span>constraint_primary }</p>

<p>constraint_primary ::= [ implicit_class_handle <span
style='color:red'>. </span>| class_scope ] hierarchical_identifier select</p>

<p>constraint_expression ::=</p>

<p>[ <span style='color:red'>soft </span>]
expression_or_dist <span style='color:red'>;</span></p>

<p>| uniqueness_constraint <span style='color:red'>;</span></p>

<p>| expression <span style='color:red;position:relative;
top:-1.0pt'>-</span><span style='color:red'>&gt; </span>constraint_set</p>

<p>| <span style='color:red'>if ( </span>expression <span
style='color:red'>) </span>constraint_set [ <span style='color:red'>else
</span>constraint_set ]</p>

 

 

<p>     </p>

 

 

<p>| <span style='color:red'>foreach ( </span>ps_or_hierarchical_array_identifier
<span style='color:red'>[ </span>loop_variables <span style='color:red'>]
) </span>constraint_set | <span style='color:red'>disable soft </span>constraint_primary
<span style='color:red'>;</span></p>

<p>uniqueness_constraint ::=</p>

<p><span style='color:red'>unique { </span>open_range_list<span
style='color:blue;position:relative;top:-4.0pt'>9 </span><span
style='color:red'>}</span></p>

<p>constraint_set ::= constraint_expression</p>

<p>| <span style='color:red'>{ </span>{
constraint_expression } <span style='color:red'>} </span>dist_list ::=
dist_item { <span style='color:red'>, </span>dist_item } dist_item ::=
value_range [ dist_weight ]</p>

<p>dist_weight ::=</p>

<p><span style='color:red'>:= </span>expression</p>

<p>| <span style='color:red'>:/ </span>expression</p>

<p>constraint_prototype ::= [constraint_prototype_qualifier] [ <span
style='color:red'>static </span>] <span style='color:red'>constraint </span>constraint_identifier
<span style='color:red'>;</span></p>

<p>constraint_prototype_qualifier ::= <span style='color:red'>extern
</span>| <span style='color:red'>pure</span></p>

<p>extern_constraint_declaration ::=</p>

<p>[ <span style='color:red'>static </span>] <span
style='color:red'>constraint </span>class_scope constraint_identifier
constraint_block</p>

<p>identifier_list ::= identifier { <span style='color:red'>,
</span>identifier }  // A.1.11 Package items</p>

<p>package_item ::= package_or_generate_item_declaration</p>

<p>| anonymous_program</p>

<p>| package_export_declaration</p>

<p>| timeunits_declaration<span style='color:blue;position:
relative;top:-4.0pt'>3</span></p>

<p>package_or_generate_item_declaration ::= net_declaration</p>

<p>| data_declaration</p>

<p>| task_declaration</p>

<p>| function_declaration</p>

<p>| checker_declaration</p>

<p>| dpi_import_export</p>

<p>| extern_constraint_declaration</p>

<p>| class_declaration</p>

<p>| class_constructor_declaration</p>

<p>| local_parameter_declaration <span style='color:red'>;</span></p>

<p>| parameter_declaration <span style='color:red'>;</span></p>

<p>| covergroup_declaration</p>

<p>| assertion_item_declaration |<span style='color:red'>;</span></p>

<p>anonymous_program::=<span style='color:red'>program ;</span>{anonymous_program_item}<span
style='color:red'>endprogram</span></p>

<p><span style='color:red'> </span> anonymous_program_item
::= task_declaration</p>

<p>| function_declaration</p>

<p>| class_declaration</p>

<p>| covergroup_declaration</p>

<p>| class_constructor_declaration |<span style='color:red'>;</span></p>

 

 

 

 

 

<p> // A.2 Declarations</p>

<p> // A.2.1 Declaration types</p>

<p> // A.2.1.1 Module parameter declarations</p>

<p>local_parameter_declaration ::=</p>

<p><span style='color:red'>localparam </span>data_type_or_implicit
list_of_param_assignments | <span style='color:red'>localparam type </span>list_of_type_assignments</p>

<p>parameter_declaration ::=</p>

<p><span style='color:red'>parameter </span>data_type_or_implicit
list_of_param_assignments</p>

<p>| <span style='color:red'>parameter type </span>list_of_type_assignments
specparam_declaration ::=</p>

<p><span style='color:red'>specparam </span>[ packed_dimension
] list_of_specparam_assignments <span style='color:red'>; </span> // A.2.1.2
Port declarations</p>

<p>inout_declaration ::=</p>

<p><span style='color:red'>inout </span>net_port_type
list_of_port_identifiers</p>

<p>input_declaration ::=</p>

<p><span style='color:red'>input </span>net_port_type
list_of_port_identifiers</p>

<p>| <span style='color:red'>input </span>variable_port_type
list_of_variable_identifiers</p>

<p>output_declaration ::=</p>

<p><span style='color:red'>output </span>net_port_type
list_of_port_identifiers</p>

<p>| <span style='color:red'>output </span>variable_port_type
list_of_variable_port_identifiers</p>

<p>interface_port_declaration ::=</p>

<p>interface_identifier list_of_interface_identifiers</p>

<p>| interface_identifier <span style='color:red'>. </span>modport_identifier
list_of_interface_identifiers ref_declaration ::= <span style='color:red'>ref
</span>variable_port_type list_of_variable_identifiers</p>

<p> // A.2.1.3 Type declarations</p>

<p>data_declaration ::=</p>

<p>[ <span style='color:red'>const </span>] [ <span
style='color:red'>var </span>] [ lifetime ] data_type_or_implicit
list_of_variable_decl_assignments <span style='color:red'>;</span><span
style='color:blue;position:relative;top:-4.0pt'>10</span></p>

<p>| type_declaration</p>

<p>| package_import_declaration<span style='color:blue;
position:relative;top:-4.0pt'>11</span></p>

<p>| net_type_declaration</p>

<p>package_import_declaration ::=</p>

<p><span style='color:red'>import </span>package_import_item
{ <span style='color:red'>, </span>package_import_item } <span
style='color:red'>;</span></p>

<p>package_import_item ::= package_identifier <span
style='color:red'>:: </span>identifier</p>

<p>| package_identifier <span style='color:red'>:: *</span></p>

<p>package_export_declaration ::=</p>

<p><span style='color:red'>export *::* ;</span></p>

<p>| <span style='color:red'>export </span>package_import_item
{ <span style='color:red'>, </span>package_import_item } <span
style='color:red'>;</span></p>

<p>genvar_declaration ::= <span style='color:red'>genvar </span>list_of_genvar_identifiers
<span style='color:red'>;</span></p>

<p>net_declaration<span style='color:blue;position:relative;
top:-4.0pt'>12 </span>::=</p>

<p>net_type [ drive_strength | charge_strength ] [ <span
style='color:red'>vectored </span>| <span style='color:red'>scalared </span>]</p>

<p>data_type_or_implicit [ delay3 ]
list_of_net_decl_assignments <span style='color:red'>;</span></p>

<p>| net_type_identifier [ delay_control ]</p>

<p>list_of_net_decl_assignments <span style='color:red'>;</span></p>

<p>| <span style='color:red'>interconnect </span>implicit_data_type
[ <span style='color:red'># </span>delay_value ]</p>

 

 

<p>    </p>

 

 

<p>net_identifier { unpacked_dimension }</p>

<p>[ <span style='color:red'>, </span>net_identifier {
unpacked_dimension }] <span style='color:red'>;</span></p>

<p>type_declaration ::=</p>

<p><span style='color:red'>typedef </span>data_type
type_identifier { variable_dimension } <span style='color:red'>;</span></p>

<p>| <span style='color:red'>typedef </span>interface_instance_identifier
constant_bit_select <span style='color:red'>. </span>type_identifier
type_identifier <span style='color:red'>; </span>| <span style='color:red'>typedef
</span>[ <span style='color:red'>enum </span>| <span style='color:red'>struct
</span>| <span style='color:red'>union </span>| <span style='color:red'>class
</span>| <span style='color:red'>interface class </span>] type_identifier <span
style='color:red'>;</span></p>

<p>net_type_declaration ::=</p>

<p><span style='color:red'>nettype </span>data_type
net_type_identifier</p>

<p>[ <span style='color:red'>with </span>[ package_scope |
class_scope ] tf_identifier ] <span style='color:red'>;</span></p>

<p>| <span style='color:red'>nettype </span>[ package_scope
| class_scope ] net_type_identifier net_type_identifier <span style='color:
red'>;</span></p>

<p>lifetime ::= <span style='color:red'>static </span>| <span
style='color:red'>automatic </span> // A.2.2 Declaration data types</p>

<p> // A.2.2.1 Net and variable types</p>

<p>casting_type ::= simple_type | constant_primary | signing | <span
style='color:red'>string </span>| <span style='color:red'>const</span></p>

<p>data_type ::=</p>

<p>integer_vector_type [ signing ] { packed_dimension }</p>

<p>| integer_atom_type [ signing ]</p>

<p>| non_integer_type</p>

<p>| struct_union [ <span style='color:red'>packed </span>[
signing ] ] <span style='color:red'>{ </span>struct_union_member {
struct_union_member } <span style='color:red'>}</span></p>

<p>{ packed_dimension }<span style='color:blue;position:relative;
top:-4.0pt'>13</span></p>

<p>| <span style='color:red'>enum </span>[ enum_base_type ]
<span style='color:red'>{ </span>enum_name_declaration { <span
style='color:red'>, </span>enum_name_declaration } <span style='color:red'>}</span></p>

<p>{ packed_dimension }</p>

<p>| <span style='color:red'>string</span></p>

<p>| <span style='color:red'>chandle</span></p>

<p>| <span style='color:red'>virtual </span>[ <span
style='color:red'>interface </span>] interface_identifier [
parameter_value_assignment ] [ <span style='color:red'>. </span>modport_identifier
]</p>

<p>| [ class_scope | package_scope ] type_identifier {
packed_dimension }</p>

<p>| class_type</p>

<p>| <span style='color:red'>event</span></p>

<p>| ps_covergroup_identifier</p>

<p>| type_reference<span style='color:blue;position:relative;
top:-4.0pt'>14</span></p>

<p>data_type_or_implicit ::= data_type</p>

<p>| implicit_data_type</p>

<p>implicit_data_type ::= [ signing ] { packed_dimension }</p>

<p>enum_base_type ::= integer_atom_type [ signing ]</p>

<p>| integer_vector_type [ signing ] [ packed_dimension ]</p>

<p>| type_identifier [ packed_dimension ]<span
style='color:blue;position:relative;top:-4.0pt'>15 </span>enum_name_declaration
::=</p>

<p>enum_identifier [ <span style='color:red'>[ </span>integral_number
[ <span style='color:red'>: </span>integral_number ] <span
style='color:red'>] </span>] [ <span style='color:red'>= </span>constant_expression
]</p>

<p>class_scope ::= class_type <span style='color:red'>::</span></p>

<p>class_type ::=</p>

<p>ps_class_identifier [ parameter_value_assignment ]</p>

<p>{ <span style='color:red'>:: </span>class_identifier [
parameter_value_assignment ] } integer_type ::= integer_vector_type |
integer_atom_type integer_atom_type ::= <span style='color:red'>byte </span>|
<span style='color:red'>shortint </span>| <span style='color:red'>int </span>|
<span style='color:red'>longint </span>| <span style='color:red'>integer
</span>| <span style='color:red'>time </span>integer_vector_type ::= <span
style='color:red'>bit </span>| <span style='color:red'>logic </span>| <span
style='color:red'>reg</span></p>

 

 

<p>    </p>

 

 

<p>non_integer_type ::= <span style='color:red'>shortreal </span>|
<span style='color:red'>real </span>| <span style='color:red'>realtime</span></p>

<p>net_type ::= <span style='color:red'>supply0 </span>| <span
style='color:red'>supply1 </span>| <span style='color:red'>tri </span>|
<span style='color:red'>triand </span>| <span style='color:red'>trior </span>|
<span style='color:red'>trireg</span>| <span style='color:red'>tri0 </span>|
<span style='color:red'>tri1 </span>| <span style='color:red'>uwire</span>|
<span style='color:red'>wire </span>| <span style='color:red'>wand </span>|
<span style='color:red'>wor</span></p>

<p>net_port_type ::=</p>

<p>[ net_type ] data_type_or_implicit</p>

<p>| net_type_identifier</p>

<p>| <span style='color:red'>interconnect </span>implicit_data_type</p>

<p>variable_port_type ::= var_data_type</p>

<p>var_data_type ::= data_type | <span style='color:red'>var
</span>data_type_or_implicit</p>

<p>signing ::= <span style='color:red'>signed </span>| <span
style='color:red'>unsigned</span></p>

<p>simple_type ::= integer_type | non_integer_type |
ps_type_identifier | ps_parameter_identifier</p>

<p>struct_union_member<span style='color:blue;position:relative;
top:-4.0pt'>16 </span>::=</p>

<p>{ attribute_instance } [random_qualifier] data_type_or_void
list_of_variable_decl_assignments <span style='color:red'>;</span></p>

<p>data_type_or_void ::= data_type | <span style='color:red'>void
</span>struct_union ::= <span style='color:red'>struct </span>| <span
style='color:red'>union </span>[ <span style='color:red'>tagged </span>]
type_reference ::=</p>

<p><span style='color:red'>type ( </span>expression<span
style='color:blue;position:relative;top:-4.0pt'>17 </span><span
style='color:red'>) </span>| <span style='color:red'>type ( </span>data_type
<span style='color:red'>)</span></p>

<p> // A.2.2.2 Strengths</p>

<p>drive_strength ::=</p>

<p><span style='color:red'>( </span>strength0 , strength1 <span
style='color:red'>)</span></p>

<p>| <span style='color:red'>( </span>strength1 , strength0
<span style='color:red'>) </span>| <span style='color:red'>( </span>strength0
, <span style='color:red'>highz1 )</span></p>

<p>| <span style='color:red'>( </span>strength1 , <span
style='color:red'>highz0 )</span></p>

<p>| <span style='color:red'>( highz0 </span>, strength1 <span
style='color:red'>)</span></p>

<p>| <span style='color:red'>( highz1 </span>, strength0 <span
style='color:red'>)</span></p>

<p>strength0 ::= <span style='color:red'>supply0 </span>| <span
style='color:red'>strong0 </span>| <span style='color:red'>pull0 </span>|
<span style='color:red'>weak0</span></p>

<p>strength1 ::= <span style='color:red'>supply1 </span>| <span
style='color:red'>strong1 </span>| <span style='color:red'>pull1 </span>|
<span style='color:red'>weak1 </span>charge_strength::=<span
style='color:red'>( small )</span>|<span style='color:red'>( medium )</span>|<span
style='color:red'>( large )</span></p>

<p> // A.2.2.3 Delays</p>

<p>delay3::=<span style='color:red'>#</span>delay_value|<span
style='color:red'># (</span>mintypmax_expression[<span style='color:red'>,</span>mintypmax_expression[<span
style='color:red'>, </span>mintypmax_expression ] ] <span style='color:
red'>)</span></p>

<p>delay2::=<span style='color:red'>#</span>delay_value|<span
style='color:red'># (</span>mintypmax_expression[<span style='color:red'>,</span>mintypmax_expression]<span
style='color:red'>)</span></p>

<p>delay_value ::= unsigned_number</p>

<p>| real_number</p>

<p>| ps_identifier</p>

<p>| time_literal</p>

<p>| <span style='color:red'>1step</span></p>

<p> // A.2.3 Declaration lists</p>

<p>list_of_defparam_assignments ::= defparam_assignment { <span
style='color:red'>, </span>defparam_assignment }</p>

<p>list_of_genvar_identifiers ::= genvar_identifier { <span
style='color:red'>, </span>genvar_identifier }</p>

<p>list_of_interface_identifiers ::= interface_identifier {
unpacked_dimension } { <span style='color:red'>, </span>interface_identifier
{ unpacked_dimension } }</p>

<p>list_of_net_decl_assignments ::= net_decl_assignment { <span
style='color:red'>, </span>net_decl_assignment }  </p>

 

<p>   </p>

 

 

<p>list_of_param_assignments ::= param_assignment { <span
style='color:red'>, </span>param_assignment } list_of_port_identifiers ::=
port_identifier { unpacked_dimension }</p>

<p>{ <span style='color:red'>, </span>port_identifier {
unpacked_dimension } }</p>

<p>list_of_udp_port_identifiers ::= port_identifier { <span
style='color:red'>, </span>port_identifier }</p>

<p>list_of_specparam_assignments ::= specparam_assignment { <span
style='color:red'>, </span>specparam_assignment }</p>

<p>list_of_tf_variable_identifiers ::= port_identifier {
variable_dimension } [ <span style='color:red'>= </span>expression ] { <span
style='color:red'>, </span>port_identifier { variable_dimension } [ <span
style='color:red'>= </span>expression ] }</p>

<p>list_of_type_assignments ::= type_assignment { <span
style='color:red'>, </span>type_assignment }</p>

<p>list_of_variable_decl_assignments ::=
variable_decl_assignment { <span style='color:red'>, </span>variable_decl_assignment
}</p>

<p>list_of_variable_identifiers ::= variable_identifier {
variable_dimension } { <span style='color:red'>, </span>variable_identifier
{ variable_dimension } }</p>

<p>list_of_variable_port_identifiers ::= port_identifier {
variable_dimension } [ <span style='color:red'>= </span>constant_expression
] { <span style='color:red'>, </span>port_identifier { variable_dimension }
[ <span style='color:red'>= </span>constant_expression ] }</p>

<p> // A.2.4 Declaration assignments</p>

<p>defparam_assignment ::= hierarchical_parameter_identifier <span
style='color:red'>= </span>constant_mintypmax_expression
net_decl_assignment ::= net_identifier { unpacked_dimension } [ <span
style='color:red'>= </span>expression ] param_assignment ::=</p>

<p>parameter_identifier { unpacked_dimension } [ <span
style='color:red'>= </span>constant_param_expression ]<span
style='color:blue;position:relative;top:-4.0pt'>18</span></p>

<p>specparam_assignment ::=</p>

<p>specparam_identifier <span style='color:red'>= </span>constant_mintypmax_expression</p>

<p>| pulse_control_specparam type_assignment ::=</p>

<p>type_identifier [ <span style='color:red'>= </span>data_type
]<span style='color:blue;position:relative;top:-4.0pt'>18</span></p>

<p>pulse_control_specparam ::=</p>

<p><span style='color:red'>PATHPULSE$ = ( </span>reject_limit_value
[ <span style='color:red'>, </span>error_limit_value ] <span
style='color:red'>)</span></p>

<p>| <span style='color:red'>PATHPULSE$</span>specify_input_terminal_descriptor<span
style='color:red'>$</span>specify_output_terminal_descriptor <span
style='color:red'>= (</span>reject_limit_value[<span style='color:red'>,</span>error_limit_value]<span
style='color:red'>)</span></p>

<p>error_limit_value ::= limit_value reject_limit_value ::=
limit_value</p>

<p>limit_value ::= constant_mintypmax_expression</p>

<p>variable_decl_assignment ::=</p>

<p>variable_identifier { variable_dimension } [ <span
style='color:red'>= </span>expression ]</p>

<p>| dynamic_array_variable_identifier unsized_dimension {
variable_dimension } [ <span style='color:red'>= </span>dynamic_array_new ]</p>

<p>| class_variable_identifier [ <span style='color:red'>= </span>class_new
]</p>

<p>class_new<span style='color:blue;position:relative;
top:-4.0pt'>19 </span>::=</p>

<p>[ class_scope ] <span style='color:red'>new </span>[ <span
style='color:red'>( </span>list_of_arguments <span style='color:red'>) </span>]</p>

<p>| <span style='color:red'>new </span>expression</p>

<p>dynamic_array_new::=<span style='color:red'>new [</span>expression<span
style='color:red'>]</span>[<span style='color:red'>(</span>expression<span
style='color:red'>)</span>]</p>

<p>    // A.2.5 Declaration ranges</p>

<p>unpacked_dimension ::= <span style='color:red'>[ </span>constant_range
<span style='color:red'>]</span></p>

<p>| <span style='color:red'>[ </span>constant_expression <span
style='color:red'>]</span></p>

 

 

 

 

 

<p>packed_dimension<span style='color:blue;position:relative;
top:-4.0pt'>20 </span>::= <span style='color:red'>[ </span>constant_range <span
style='color:red'>] </span>| unsized_dimension</p>

<p>associative_dimension ::= <span style='color:red'>[ </span>data_type
<span style='color:red'>]</span></p>

<p>|<span style='color:red'>[*]</span></p>

<p>variable_dimension ::= unsized_dimension</p>

<p>| unpacked_dimension</p>

<p>| associative_dimension</p>

<p>| queue_dimension</p>

<p>queue_dimension::=<span style='color:red'>[ $</span>[<span
style='color:red'>:</span>constant_expression]<span style='color:red'>]
</span>unsized_dimension::=<span style='color:red'>[ ]</span></p>

<p> // A.2.6 Function declarations</p>

<p>function_data_type_or_implicit ::= data_type_or_void</p>

<p>| implicit_data_type</p>

<p>function_declaration ::= <span style='color:red'>function
</span>[ lifetime ] function_body_declaration</p>

<p>function_body_declaration ::= function_data_type_or_implicit</p>

<p>[ interface_identifier <span style='color:red'>. </span>|
class_scope ] function_identifier <span style='color:red'>; </span>{
tf_item_declaration }</p>

<p>{ function_statement_or_null }</p>

<p><span style='color:red'>endfunction </span>[ <span
style='color:red'>: </span>function_identifier ]</p>

<p>| function_data_type_or_implicit</p>

<p>[ interface_identifier <span style='color:red'>. </span>|
class_scope ] function_identifier <span style='color:red'>( </span>[ tf_port_list
] <span style='color:red'>) ;</span></p>

<p>{ block_item_declaration }</p>

<p>{ function_statement_or_null } <span style='color:red'>endfunction
</span>[ <span style='color:red'>: </span>function_identifier ]</p>

<p>function_prototype ::= <span style='color:red'>function </span>data_type_or_void
function_identifier [ <span style='color:red'>( </span>[ tf_port_list ] <span
style='color:red'>) </span>]</p>

<p>dpi_import_export ::=</p>

<p><span style='color:red'>import </span>dpi_spec_string [
dpi_function_import_property ] [ c_identifier <span style='color:red'>= </span>]
dpi_function_proto <span style='color:red'>;</span></p>

<p>| <span style='color:red'>import </span>dpi_spec_string
[ dpi_task_import_property ] [ c_identifier <span style='color:red'>= </span>]
dpi_task_proto <span style='color:red'>; </span>| <span style='color:red'>export
</span>dpi_spec_string [ c_identifier <span style='color:red'>= </span>] <span
style='color:red'>function </span>function_identifier <span
style='color:red'>;</span></p>

<p>| <span style='color:red'>export </span>dpi_spec_string
[ c_identifier <span style='color:red'>= </span>] <span style='color:red'>task
</span>task_identifier <span style='color:red'>;</span></p>

<p>dpi_spec_string ::= <span style='color:red'>&quot;DPI-C&quot;
</span>| <span style='color:red'>&quot;DPI&quot; </span>dpi_function_import_property
::= <span style='color:red'>context </span>| <span style='color:red'>pure
</span>dpi_task_import_property ::= <span style='color:red'>context</span></p>

<p>dpi_function_proto<span style='color:blue;position:relative;
top:-4.0pt'>21</span><span style='position:relative;top:-4.0pt'>,<span
style='color:blue'>22 </span></span>::= function_prototype dpi_task_proto<span
style='color:blue;position:relative;top:-4.0pt'>22 </span>::= task_prototype</p>

<p> // A.2.7 Task declarations</p>

<p>task_declaration ::= <span style='color:red'>task </span>[
lifetime ] task_body_declaration task_body_declaration ::=</p>

<p>[ interface_identifier <span style='color:red'>. </span>|
class_scope ] task_identifier <span style='color:red'>; </span> </p>

 

<p>     </p>

 

 

<p>{ tf_item_declaration }</p>

<p>{ statement_or_null } <span style='color:red'>endtask </span>[
<span style='color:red'>: </span>task_identifier ]</p>

<p>| [ interface_identifier <span style='color:red'>. </span>|
class_scope ] task_identifier <span style='color:red'>( </span>[
tf_port_list ] <span style='color:red'>) ; </span>{ block_item_declaration
}</p>

<p>{ statement_or_null }</p>

<p><span style='color:red'>endtask </span>[ <span
style='color:red'>: </span>task_identifier ]</p>

<p>tf_item_declaration ::= block_item_declaration</p>

<p>| tf_port_declaration tf_port_list ::=</p>

<p>tf_port_item { <span style='color:red'>, </span>tf_port_item
}</p>

<p>tf_port_item<span style='color:blue;position:relative;
top:-4.0pt'>23 </span>::=</p>

<p>{ attribute_instance }</p>

<p>[ tf_port_direction ] [ <span style='color:red'>var </span>]
data_type_or_implicit</p>

<p>[ port_identifier { variable_dimension } [ <span
style='color:red'>= </span>expression ] ]</p>

<p>tf_port_direction ::= port_direction | <span
style='color:red'>const ref </span>tf_port_declaration ::=</p>

<p>{ attribute_instance } tf_port_direction [ <span
style='color:red'>var </span>] data_type_or_implicit
list_of_tf_variable_identifiers <span style='color:red'>; </span>task_prototype
::= <span style='color:red'>task </span>task_identifier [ <span
style='color:red'>( </span>[ tf_port_list ] <span style='color:red'>) </span>]</p>

<p> // A.2.8 Block item declarations</p>

<p>block_item_declaration ::=</p>

<p>{ attribute_instance } data_declaration</p>

<p>| { attribute_instance } local_parameter_declaration <span
style='color:red'>;</span></p>

<p>| { attribute_instance } parameter_declaration <span
style='color:red'>;</span></p>

<p>| { attribute_instance } let_declaration</p>

<p> // A.2.9 Interface declarations</p>

<p>modport_declaration ::= <span style='color:red'>modport </span>modport_item
{ <span style='color:red'>, </span>modport_item } <span style='color:red'>;</span></p>

<p>modport_item ::= modport_identifier <span style='color:red'>(
</span>modport_ports_declaration { <span style='color:red'>, </span>modport_ports_declaration
} <span style='color:red'>)</span></p>

<p>modport_ports_declaration ::=</p>

<p>{ attribute_instance } modport_simple_ports_declaration</p>

<p>| { attribute_instance } modport_tf_ports_declaration</p>

<p>| { attribute_instance } modport_clocking_declaration</p>

<p>modport_clocking_declaration ::= <span style='color:red'>clocking
</span>clocking_identifier modport_simple_ports_declaration ::=</p>

<p>port_direction modport_simple_port { <span style='color:
red'>, </span>modport_simple_port }</p>

<p>modport_simple_port ::= port_identifier</p>

<p>| <span style='color:red'>. </span>port_identifier <span
style='color:red'>( </span>[ expression ] <span style='color:red'>) </span>modport_tf_ports_declaration
::=</p>

<p>import_export modport_tf_port { <span style='color:red'>,
</span>modport_tf_port }</p>

<p> modport_tf_port ::= method_prototype</p>

<p>| tf_identifier</p>

<p>import_export ::= <span style='color:red'>import </span>|
<span style='color:red'>export</span></p>

 

 

 

 

 

<p> // A.2.10 Assertion declarations</p>

<p>concurrent_assertion_item ::=</p>

<p>[ block_identifier <span style='color:red'>: </span>]
concurrent_assertion_statement</p>

<p>| checker_instantiation</p>

<p>concurrent_assertion_statement ::= assert_property_statement</p>

<p>| assume_property_statement</p>

<p>| cover_property_statement</p>

<p>| cover_sequence_statement</p>

<p>| restrict_property_statement</p>

<p>assert_property_statement::=</p>

<p><span style='color:red'>assert property ( </span>property_spec
<span style='color:red'>) </span>action_block</p>

<p>assume_property_statement::=</p>

<p><span style='color:red'>assume property ( </span>property_spec
<span style='color:red'>) </span>action_block</p>

<p>cover_property_statement::=</p>

<p><span style='color:red'>cover property ( </span>property_spec
<span style='color:red'>) </span>statement_or_null</p>

<p>expect_property_statement ::=</p>

<p><span style='color:red'>expect (</span>property_spec<span
style='color:red'>)</span>action_block</p>

<p>cover_sequence_statement::=</p>

<p><span style='color:red'>cover sequence (</span>[clocking_event][<span
style='color:red'>disable iff (</span>expression_or_dist<span
style='color:red'>)</span>]</p>

<p>sequence_expr <span style='color:red'>) </span>statement_or_null
restrict_property_statement::=</p>

<p><span style='color:red'>restrict property ( </span>property_spec
<span style='color:red'>) ; </span>property_instance ::=</p>

<p>ps_or_hierarchical_property_identifier [ <span
style='color:red'>( </span>[ property_list_of_arguments ] <span
style='color:red'>) </span>]</p>

<p>property_list_of_arguments ::=</p>

<p>[property_actual_arg] { <span style='color:red'>, </span>[property_actual_arg]
} { <span style='color:red'>, . </span>identifier <span style='color:red'>(
</span>[property_actual_arg] <span style='color:red'>) </span>}</p>

<p>| <span style='color:red'>. </span>identifier <span
style='color:red'>( </span>[property_actual_arg] <span style='color:red'>)
</span>{ <span style='color:red'>, . </span>identifier <span
style='color:red'>( </span>[property_actual_arg] <span style='color:red'>)
</span>}</p>

<p>property_actual_arg ::= property_expr</p>

<p>| sequence_actual_arg</p>

<p>assertion_item_declaration ::= property_declaration</p>

<p>| sequence_declaration</p>

<p>| let_declaration</p>

<p>property_declaration ::=</p>

<p><span style='color:red'>property </span>property_identifier
[ <span style='color:red'>( </span>[ property_port_list ] <span
style='color:red'>) </span>] <span style='color:red'>;</span></p>

<p>{ assertion_variable_declaration } property_spec [ <span
style='color:red'>; </span>]</p>

<p><span style='color:red'>endproperty </span>[ <span
style='color:red'>: </span>property_identifier ] property_port_list ::=</p>

<p>property_port_item {<span style='color:red'>, </span>property_port_item}</p>

<p>property_port_item ::=</p>

<p>{ attribute_instance } [ <span style='color:red'>local </span>[
property_lvar_port_direction ] ] property_formal_type</p>

<p>formal_port_identifier {variable_dimension} [ <span
style='color:red'>= </span>property_actual_arg ]</p>

<p>property_lvar_port_direction ::= <span style='color:red'>input</span></p>

<p>property_formal_type ::= sequence_formal_type</p>

<p>| <span style='color:red'>property</span></p>

 

 

 

 

 

<p>property_spec ::=</p>

<p>[clocking_event][<span style='color:red'>disable iff(</span>expression_or_dist<span
style='color:red'>)</span>]property_expr</p>

<p>property_expr ::= sequence_expr</p>

<p>| <span style='color:red'>strong ( </span>sequence_expr <span
style='color:red'>) </span>| <span style='color:red'>weak ( </span>sequence_expr
<span style='color:red'>)</span></p>

<p>| <span style='color:red'>( </span>property_expr <span
style='color:red'>)</span></p>

<p>| <span style='color:red'>not </span>property_expr</p>

<p>| property_expr <span style='color:red'>or </span>property_expr</p>

<p>| property_expr <span style='color:red'>and </span>property_expr</p>

<p>| sequence_expr <span style='color:red'>|-&gt; </span>property_expr</p>

<p>| sequence_expr <span style='color:red'>|=&gt; </span>property_expr</p>

<p>| <span style='color:red'>if </span>( expression_or_dist
) property_expr [ <span style='color:red'>else </span>property_expr ]</p>

<p>| <span style='color:red'>case </span>(
expression_or_dist ) property_case_item { property_case_item } <span
style='color:red'>endcase </span>| sequence_expr <span style='color:red'>#-#
</span>property_expr</p>

<p>| sequence_expr <span style='color:red'>#=# </span>property_expr</p>

<p>| <span style='color:red'>nexttime </span>property_expr</p>

<p>| <span style='color:red'>nexttime [ </span>constant
_expression <span style='color:red'>] </span>property_expr</p>

<p>| <span style='color:red'>s_nexttime </span>property_expr</p>

<p>| <span style='color:red'>s_nexttime [ </span>constant_expression
<span style='color:red'>] </span>property_expr</p>

<p>| <span style='color:red'>always </span>property_expr</p>

<p>| <span style='color:red'>always [ </span>cycle_delay_const_range_expression
<span style='color:red'>] </span>property_expr</p>

<p>| <span style='color:red'>s_always [ </span>constant_range]
property_expr</p>

<p>| <span style='color:red'>s_eventually </span>property_expr</p>

<p>| <span style='color:red'>eventually [ </span>constant_range
<span style='color:red'>] </span>property_expr</p>

<p>| <span style='color:red'>s_eventually [ </span>cycle_delay_const_range_expression
<span style='color:red'>] </span>property_expr</p>

<p>| property_expr <span style='color:red'>until </span>property_expr</p>

<p>| property_expr <span style='color:red'>s_until </span>property_expr</p>

<p>| property_expr <span style='color:red'>until_with </span>property_expr</p>

<p>| property_expr <span style='color:red'>s_until_with </span>property_expr</p>

<p>| property_expr <span style='color:red'>implies </span>property_expr</p>

<p>| property_expr <span style='color:red'>iff </span>property_expr</p>

<p>| <span style='color:red'>accept_on ( </span>expression_or_dist
<span style='color:red'>) </span>property_expr</p>

<p>| <span style='color:red'>reject_on ( </span>expression_or_dist
<span style='color:red'>) </span>property_expr</p>

<p>| <span style='color:red'>sync_accept_on ( </span>expression_or_dist
<span style='color:red'>) </span>property_expr</p>

<p>| <span style='color:red'>sync_reject_on ( </span>expression_or_dist
<span style='color:red'>) </span>property_expr</p>

<p>| property_instance</p>

<p>| clocking_event property_expr</p>

<p>property_case_item ::=</p>

<p>expression_or_dist { <span style='color:red'>, </span>expression_or_dist
} <span style='color:red'>: </span>property_expr <span style='color:red'>;</span></p>

<p>| <span style='color:red'>default </span>[ <span
style='color:red'>: </span>] property_expr <span style='color:red'>;</span></p>

<p>sequence_declaration ::=</p>

<p><span style='color:red'>sequence </span>sequence_identifier
[ <span style='color:red'>( </span>[ sequence_port_list ] <span
style='color:red'>) </span>] <span style='color:red'>;</span></p>

<p>{ assertion_variable_declaration }</p>

<p>sequence_expr [ <span style='color:red'>; </span>]</p>

<p><span style='color:red'>endsequence </span>[ <span
style='color:red'>: </span>sequence_identifier ]</p>

<p>sequence_port_list ::=</p>

<p>sequence_port_item {<span style='color:red'>, </span>sequence_port_item}</p>

<p>sequence_port_item ::=</p>

<p>{ attribute_instance } [ <span style='color:red'>local </span>[
sequence_lvar_port_direction ] ] sequence_formal_type</p>

<p>formal_port_identifier {variable_dimension} [ <span
style='color:red'>= </span>sequence_actual_arg ]
sequence_lvar_port_direction ::= <span style='color:red'>input </span>| <span
style='color:red'>inout </span>| <span style='color:red'>output</span></p>

 

 

 

 

 

<p>sequence_formal_type ::= data_type_or_implicit</p>

<p>| <span style='color:red'>sequence </span>| <span
style='color:red'>untyped</span></p>

<p>sequence_expr ::=</p>

<p>cycle_delay_range sequence_expr { cycle_delay_range
sequence_expr }</p>

<p>| sequence_expr cycle_delay_range sequence_expr { cycle_delay_range
sequence_expr }</p>

<p>| expression_or_dist [ boolean_abbrev ]</p>

<p>| sequence_instance [ sequence_abbrev ]</p>

<p>| <span style='color:red'>( </span>sequence_expr {<span
style='color:red'>, </span>sequence_match_item } <span style='color:red'>)
</span>[ sequence_abbrev ]</p>

<p>| sequence_expr <span style='color:red'>and </span>sequence_expr</p>

<p>| sequence_expr <span style='color:red'>intersect </span>sequence_expr</p>

<p>| sequence_expr <span style='color:red'>or </span>sequence_expr</p>

<p>| <span style='color:red'>first_match ( </span>sequence_expr
{<span style='color:red'>, </span>sequence_match_item} <span
style='color:red'>)</span></p>

<p>| expression_or_dist <span style='color:red'>throughout </span>sequence_expr</p>

<p>| sequence_expr <span style='color:red'>within </span>sequence_expr
| clocking_event sequence_expr</p>

<p>cycle_delay_range ::=</p>

<p><span style='color:red'>## </span>constant_primary</p>

<p>| <span style='color:red'>## [ </span>cycle_delay_const_range_expression
<span style='color:red'>] </span>| <span style='color:red'>##[*]</span></p>

<p>| <span style='color:red'>##[+]</span></p>

<p>sequence_method_call ::= sequence_instance <span
style='color:red'>. </span>method_identifier</p>

<p>sequence_match_item ::= operator_assignment</p>

<p>| inc_or_dec_expression</p>

<p>| subroutine_call</p>

<p>sequence_instance ::=</p>

<p>ps_or_hierarchical_sequence_identifier [ <span
style='color:red'>( </span>[ sequence_list_of_arguments ] <span
style='color:red'>) </span>]</p>

<p>sequence_list_of_arguments ::=</p>

<p>[sequence_actual_arg] { <span style='color:red'>, </span>[sequence_actual_arg]
} { <span style='color:red'>, . </span>identifier <span style='color:red'>(
</span>[sequence_actual_arg] <span style='color:red'>) </span>}</p>

<p>| <span style='color:red'>. </span>identifier <span
style='color:red'>( </span>[sequence_actual_arg] <span style='color:red'>)
</span>{ <span style='color:red'>, . </span>identifier <span
style='color:red'>( </span>[sequence_actual_arg] <span style='color:red'>)
</span>}</p>

<p>sequence_actual_arg ::= event_expression</p>

<p>| sequence_expr</p>

<p>boolean_abbrev ::= consecutive_repetition</p>

<p>| non_consecutive_repetition</p>

<p>| goto_repetition</p>

<p>sequence_abbrev ::= consecutive_repetition</p>

<p>consecutive_repetition ::=</p>

<p><span style='color:red'>[* </span>const_or_range_expression
<span style='color:red'>]</span></p>

<p>| <span style='color:red'>[*] </span>| <span
style='color:red'>[+]</span></p>

<p>non_consecutive_repetition ::= <span style='color:red'>[=
</span>const_or_range_expression <span style='color:red'>]</span></p>

<p>goto_repetition ::= <span style='color:red'>[-&gt; </span>const_or_range_expression
<span style='color:red'>]</span></p>

<p>const_or_range_expression ::= constant_expression</p>

<p>| cycle_delay_const_range_expression</p>

 

 

 

 

 

<p>cycle_delay_const_range_expression ::= constant_expression <span
style='color:red'>: </span>constant_expression</p>

<p>| constant_expression <span style='color:red'>: $</span></p>

<p>expression_or_dist ::= expression [ <span style='color:red'>dist
{ </span>dist_list <span style='color:red'>} </span>]</p>

<p>assertion_variable_declaration ::=</p>

<p>var_data_type list_of_variable_decl_assignments <span
style='color:red'>;</span></p>

<p> // A.2.11 Covergroup declarations</p>

<p>covergroup_declaration ::=</p>

<p><span style='color:red'>covergroup </span>covergroup_identifier
[ <span style='color:red'>( </span>[ tf_port_list ] <span style='color:
red'>) </span>] [ coverage_event ] <span style='color:red'>;</span></p>

<p>{ coverage_spec_or_option } <span style='color:red'>endgroup
</span>[ <span style='color:red'>: </span>covergroup_identifier ]</p>

<p>coverage_spec_or_option ::= {attribute_instance}
coverage_spec</p>

<p>| {attribute_instance} coverage_option <span
style='color:red'>;</span></p>

<p>coverage_option ::= <span style='color:red'>option.</span>member_identifier
<span style='color:red'>= </span>expression</p>

<p>| <span style='color:red'>type_option.</span>member_identifier
<span style='color:red'>= </span>constant_expression</p>

<p>coverage_spec ::= cover_point</p>

<p>| cover_cross</p>

<p>coverage_event ::= clocking_event</p>

<p>| <span style='color:red'>with function sample ( </span>[
tf_port_list ] <span style='color:red'>) </span>| <span style='color:red'>@@(
</span>block_event_expression <span style='color:red'>)</span></p>

<p>block_event_expression ::=</p>

<p>block_event_expression <span style='color:red'>or </span>block_event_expression</p>

<p>| <span style='color:red'>begin </span>hierarchical_btf_identifier
| <span style='color:red'>end </span>hierarchical_btf_identifier</p>

<p>hierarchical_btf_identifier ::= hierarchical_tf_identifier</p>

<p>| hierarchical_block_identifier</p>

<p>| [ hierarchical_identifier<span style='color:red'>. </span>|
class_scope ] method_identifier</p>

<p>cover_point ::=</p>

<p>[ [ data_type_or_implicit ] cover_point_identifier <span
style='color:red'>: </span>] <span style='color:red'>coverpoint </span>expression
[ <span style='color:red'>iff ( </span>expression <span style='color:red'>)
</span>]</p>

<p>bins_or_empty</p>

<p>bins_or_empty ::=</p>

<p><span style='color:red'>{ </span>{attribute_instance} {
bins_or_options <span style='color:red'>; </span>} <span style='color:red'>}</span></p>

<p>|<span style='color:red'>;</span></p>

<p>bins_or_options ::= coverage_option</p>

<p>| [ <span style='color:red'>wildcard </span>]
bins_keyword bin_identifier [ <span style='color:red'>[ </span>[
covergroup_expression ] <span style='color:red'>] </span>] <span
style='color:red'>= { </span>covergroup_range_list <span style='color:red'>}
</span>[ <span style='color:red'>with ( </span>with_covergroup_expression <span
style='color:red'>) </span>]</p>

<p>[ <span style='color:red'>iff ( </span>expression <span
style='color:red'>) </span>]</p>

<p>| [ <span style='color:red'>wildcard </span>]
bins_keyword bin_identifier [ <span style='color:red'>[ </span>[
covergroup_expression ] <span style='color:red'>] </span>] <span
style='color:red'>= </span>cover_point_identifier <span style='color:red'>with
( </span>with_covergroup_expression <span style='color:red'>) </span>[ <span
style='color:red'>iff ( </span>expression <span style='color:red'>) </span>]</p>

<p>| [ <span style='color:red'>wildcard </span>]
bins_keyword bin_identifier [ <span style='color:red'>[ </span>[
covergroup_expression ] <span style='color:red'>] </span>] <span
style='color:red'>= </span>set_covergroup_expression [ <span
style='color:red'>iff ( </span>expression <span style='color:red'>) </span>]</p>

<p>| [ <span style='color:red'>wildcard</span>]
bins_keyword bin_identifier [ <span style='color:red'>[ ] </span>] <span
style='color:red'>= </span>trans_list [ <span style='color:red'>iff ( </span>expression
<span style='color:red'>) </span>]  </p>

 

<p>  </p>

 

 

<p>| bins_keyword bin_identifier [ <span style='color:red'>[
</span>[ covergroup_expression ] <span style='color:red'>] </span>] <span
style='color:red'>= default </span>[ <span style='color:red'>iff ( </span>expression
<span style='color:red'>) </span>] | bins_keyword bin_identifier <span
style='color:red'>= default sequence </span>[ <span style='color:red'>iff
( </span>expression <span style='color:red'>) </span>]</p>

<p>bins_keyword::= <span style='color:red'>bins </span>| <span
style='color:red'>illegal_bins </span>| <span style='color:red'>ignore_bins
</span>trans_list ::= <span style='color:red'>( </span>trans_set <span
style='color:red'>) </span>{ <span style='color:red'>, ( </span>trans_set
<span style='color:red'>) </span>}</p>

<p>trans_set ::= trans_range_list { <span style='color:red'>=&gt;
</span>trans_range_list }</p>

<p>trans_range_list ::= trans_item</p>

<p>| trans_item <span style='color:red'>[* </span>repeat_range
<span style='color:red'>]</span></p>

<p>| trans_item <span style='color:red'>[-&gt; </span>repeat_range
<span style='color:red'>]</span></p>

<p>| trans_item <span style='color:red'>[= </span>repeat_range
<span style='color:red'>]</span></p>

<p>trans_item ::= covergroup_range_list</p>

<p>repeat_range ::= covergroup_expression</p>

<p>| covergroup_expression <span style='color:red'>: </span>covergroup_expression
cover_cross ::=</p>

<p>[cross_identifier<span style='color:red'>: </span>]<span
style='color:red'>cross</span>list_of_cross_items[<span style='color:red'>iff(</span>expression<span
style='color:red'>)</span>]cross_body</p>

<p>list_of_cross_items ::= cross_item <span style='color:red'>,
</span>cross_item { <span style='color:red'>, </span>cross_item }</p>

<p>cross_item ::= cover_point_identifier</p>

<p>| variable_identifier</p>

<p>cross_body ::=</p>

<p><span style='color:red'>{ </span>{ cross_body_item <span
style='color:red'>; </span>} <span style='color:red'>}</span></p>

<p>|<span style='color:red'>;</span></p>

<p>cross_body_item ::= function_declaraton</p>

<p>| bins_selection_or_option <span style='color:red'>;</span></p>

<p>bins_selection_or_option ::=</p>

<p>{ attribute_instance } coverage_option</p>

<p>| { attribute_instance } bins_selection</p>

<p>bins_selection ::= bins_keyword bin_identifier <span
style='color:red'>= </span>select_expression [ <span style='color:red'>iff
( </span>expression <span style='color:red'>) </span>]</p>

<p>select_expression<span style='color:blue;position:relative;
top:-4.0pt'>24 </span>::= select_condition</p>

<p>| <span style='color:red'>! </span>select_condition</p>

<p>| select_expression <span style='color:red'>&amp;&amp; </span>select_expression</p>

<p>| select_expression <span style='color:red'>|| </span>select_expression</p>

<p>| <span style='color:red'>( </span>select_expression <span
style='color:red'>)</span></p>

<p>| select_expression <span style='color:red'>with ( </span>with_covergroup_expression
<span style='color:red'>) </span>[ <span style='color:red'>matches </span>integer_covergroup_expression
]</p>

<p>| cross_identifier</p>

<p>| cross_set_expression [ <span style='color:red'>matches
</span>integer_covergroup_expression ]</p>

<p>select_condition::=<span style='color:red'>binsof (</span>bins_expression<span
style='color:red'>)</span>[<span style='color:red'>intersect{</span>covergroup_range_list<span
style='color:red'>}</span>]</p>

<p>bins_expression ::= variable_identifier</p>

<p>| cover_point_identifier [ <span style='color:red'>. </span>bin_identifier
]</p>

<p>covergroup_range_list ::= covergroup_value_range { <span
style='color:red'>, </span>covergroup_value_range }</p>

<p>covergroup_value_range ::= covergroup_expression</p>

<p>| <span style='color:red'>[ </span>covergroup_expression
<span style='color:red'>: </span>covergroup_expression <span
style='color:red'>]</span><span style='color:blue;position:relative;
top:-4.0pt'>25 </span>with_covergroup_expression ::= covergroup_expression<span
style='color:blue;position:relative;top:-4.0pt'>26</span></p>

 

 

<p>    </p>

 

 

<p>set_covergroup_expression ::= covergroup_expression<span
style='color:blue;position:relative;top:-4.0pt'>27 </span>integer_covergroup_expression
::= covergroup_expression cross_set_expression ::= covergroup_expression</p>

<p>covergroup_expression ::= expression<span style='color:blue;
position:relative;top:-4.0pt'>28 </span> // A.2.12 Let declarations</p>

<p>let_declaration ::=</p>

<p><span style='color:red'>let </span>let_identifier [ <span
style='color:red'>( </span>[ let_port_list ] <span style='color:red'>) </span>]
<span style='color:red'>= </span>expression <span style='color:red'>;</span></p>

<p>let_identifier ::= identifier</p>

<p>let_port_list ::=</p>

<p>let_port_item {<span style='color:red'>, </span>let_port_item}</p>

<p>let_port_item ::=</p>

<p>{ attribute_instance } let_formal_type
formal_port_identifier { variable_dimension } [ <span style='color:red'>= </span>expression
]</p>

<p>let_formal_type ::= data_type_or_implicit</p>

<p>| <span style='color:red'>untyped </span>let_expression
::=</p>

<p>[ package_scope ] let_identifier [ <span style='color:red'>(
</span>[ let_list_of_arguments ] <span style='color:red'>) </span>]</p>

<p>let_list_of_arguments ::=</p>

<p>[ let_actual_arg ] {<span style='color:red'>, </span>[
let_actual_arg ] } {<span style='color:red'>, . </span>identifier <span
style='color:red'>( </span>[ let_actual_arg ] <span style='color:red'>)
</span>}</p>

<p>| <span style='color:red'>. </span>identifier <span
style='color:red'>( </span>[ let_actual_arg ] <span style='color:red'>)
</span>{ <span style='color:red'>, . </span>identifier <span
style='color:red'>( </span>[ let_actual_arg ] <span style='color:red'>)
</span>} let_actual_arg ::=</p>

<p>expression</p>

<p> // A.3 Primitive instances</p>

<p> // A.3.1 Primitive instantiation and instances</p>

<p>gate_instantiation ::=</p>

<p>cmos_switchtype [delay3] cmos_switch_instance { <span
style='color:red'>, </span>cmos_switch_instance } <span style='color:red'>;</span></p>

<p>| enable_gatetype [drive_strength] [delay3]
enable_gate_instance { <span style='color:red'>, </span>enable_gate_instance
} <span style='color:red'>;</span></p>

<p>| mos_switchtype [delay3] mos_switch_instance { <span
style='color:red'>, </span>mos_switch_instance } <span style='color:red'>;</span></p>

<p>| n_input_gatetype [drive_strength] [delay2]
n_input_gate_instance { <span style='color:red'>, </span>n_input_gate_instance
} <span style='color:red'>;</span></p>

<p>| n_output_gatetype [drive_strength] [delay2]
n_output_gate_instance</p>

<p>{ <span style='color:red'>, </span>n_output_gate_instance
} <span style='color:red'>;</span></p>

<p>| pass_en_switchtype [delay2] pass_enable_switch_instance { <span
style='color:red'>, </span>pass_enable_switch_instance } <span
style='color:red'>;</span></p>

<p>| pass_switchtype pass_switch_instance { <span
style='color:red'>, </span>pass_switch_instance } <span style='color:red'>;</span></p>

<p>| <span style='color:red'>pulldown </span>[pulldown_strength]
pull_gate_instance { <span style='color:red'>, </span>pull_gate_instance } <span
style='color:red'>;</span></p>

<p>| <span style='color:red'>pullup </span>[pullup_strength]
pull_gate_instance { <span style='color:red'>, </span>pull_gate_instance } <span
style='color:red'>;</span></p>

<p>cmos_switch_instance ::= [ name_of_instance ] <span
style='color:red'>( </span>output_terminal <span style='color:red'>, </span>input_terminal
<span style='color:red'>, </span>ncontrol_terminal <span style='color:red'>,
</span>pcontrol_terminal <span style='color:red'>)</span></p>

<p>enable_gate_instance ::= [ name_of_instance ] <span
style='color:red'>( </span>output_terminal <span style='color:red'>, </span>input_terminal
<span style='color:red'>, </span>enable_terminal <span style='color:red'>)
</span>mos_switch_instance ::= [ name_of_instance ] <span style='color:red'>(
</span>output_terminal <span style='color:red'>, </span>input_terminal <span
style='color:red'>, </span>enable_terminal <span style='color:red'>) </span>n_input_gate_instance
::= [ name_of_instance ] <span style='color:red'>( </span>output_terminal <span
style='color:red'>, </span>input_terminal { <span style='color:red'>, </span>input_terminal
} <span style='color:red'>) </span>n_output_gate_instance ::= [
name_of_instance ] <span style='color:red'>( </span>output_terminal { <span
style='color:red'>, </span>output_terminal } <span style='color:red'>,</span></p>

 

 

<p>   </p>

 

 

<p>input_terminal <span style='color:red'>)</span></p>

<p>pass_switch_instance ::= [ name_of_instance ] <span
style='color:red'>( </span>inout_terminal <span style='color:red'>, </span>inout_terminal
<span style='color:red'>)</span></p>

<p>pass_enable_switch_instance ::= [ name_of_instance ] <span
style='color:red'>( </span>inout_terminal <span style='color:red'>, </span>inout_terminal
<span style='color:red'>, </span>enable_terminal <span style='color:red'>)</span></p>

<p>pull_gate_instance ::= [ name_of_instance ] <span
style='color:red'>( </span>output_terminal <span style='color:red'>) </span> //
A.3.2 Primitive strengths</p>

<p>pulldown_strength ::=</p>

<p><span style='color:red'>( </span>strength0 <span
style='color:red'>, </span>strength1 <span style='color:red'>)</span></p>

<p>| <span style='color:red'>( </span>strength1 <span
style='color:red'>, </span>strength0 <span style='color:red'>) </span>|
<span style='color:red'>( </span>strength0 <span style='color:red'>)</span></p>

<p>pullup_strength ::=</p>

<p><span style='color:red'>( </span>strength0 <span
style='color:red'>, </span>strength1 <span style='color:red'>)</span></p>

<p>| <span style='color:red'>( </span>strength1 <span
style='color:red'>, </span>strength0 <span style='color:red'>) </span>|
<span style='color:red'>( </span>strength1 <span style='color:red'>)</span></p>

<p> // A.3.3 Primitive terminals</p>

<p>enable_terminal ::= expression inout_terminal ::= net_lvalue
input_terminal ::= expression ncontrol_terminal ::= expression output_terminal
::= net_lvalue pcontrol_terminal ::= expression</p>

<p> // A.3.4 Primitive gate and switch types</p>

<p>cmos_switchtype ::= <span style='color:red'>cmos </span>|
<span style='color:red'>rcmos</span></p>

<p>enable_gatetype ::= <span style='color:red'>bufif0 </span>|
<span style='color:red'>bufif1 </span>| <span style='color:red'>notif0 </span>|
<span style='color:red'>notif1 </span>mos_switchtype ::= <span
style='color:red'>nmos </span>| <span style='color:red'>pmos </span>| <span
style='color:red'>rnmos </span>| <span style='color:red'>rpmos</span></p>

<p>n_input_gatetype ::= <span style='color:red'>and </span>|
<span style='color:red'>nand </span>| <span style='color:red'>or </span>|
<span style='color:red'>nor </span>| <span style='color:red'>xor </span>|
<span style='color:red'>xnor </span>n_output_gatetype ::= <span
style='color:red'>buf </span>| <span style='color:red'>not</span></p>

<p>pass_en_switchtype ::= <span style='color:red'>tranif0 </span>|
<span style='color:red'>tranif1 </span>| <span style='color:red'>rtranif1
</span>| <span style='color:red'>rtranif0 </span>pass_switchtype ::= <span
style='color:red'>tran </span>| <span style='color:red'>rtran</span></p>

<p> // A.4 Instantiations</p>

<p> // A.4.1 Instantiation</p>

<p> // A.4.1.1 Module instantiation</p>

<p>module_instantiation ::=</p>

<p>module_identifier [ parameter_value_assignment ]
hierarchical_instance { <span style='color:red'>, </span>hierarchical_instance
} <span style='color:red'>;</span></p>

<p>parameter_value_assignment::=<span style='color:red'># (</span>[list_of_parameter_assignments]<span
style='color:red'>) </span>list_of_parameter_assignments ::=</p>

<p>ordered_parameter_assignment { <span style='color:red'>,
</span>ordered_parameter_assignment }  </p>

 

 

 

 

<p>| named_parameter_assignment { <span style='color:red'>,
</span>named_parameter_assignment } ordered_parameter_assignment ::=
param_expression named_parameter_assignment ::= <span style='color:red'>. </span>parameter_identifier
<span style='color:red'>( </span>[ param_expression ] <span
style='color:red'>) </span>hierarchical_instance ::= name_of_instance <span
style='color:red'>( </span>[ list_of_port_connections ] <span
style='color:red'>) </span>name_of_instance ::= instance_identifier {
unpacked_dimension }</p>

<p>list_of_port_connections<span style='color:blue;position:
relative;top:-4.0pt'>29 </span>::=</p>

<p>ordered_port_connection { <span style='color:red'>, </span>ordered_port_connection
}</p>

<p>| named_port_connection { <span style='color:red'>, </span>named_port_connection
}</p>

<p>ordered_port_connection ::= { attribute_instance } [
expression ]</p>

<p>named_port_connection ::=</p>

<p>{ attribute_instance } <span style='color:red'>. </span>port_identifier
[ <span style='color:red'>( </span>[ expression ] <span style='color:red'>)
</span>]</p>

<p>| { attribute_instance } <span style='color:red'>.* </span> //
A.4.1.2 Interface instantiation</p>

<p>interface_instantiation ::=</p>

<p>interface_identifier [ parameter_value_assignment ]
hierarchical_instance { <span style='color:red'>, </span>hierarchical_instance
} <span style='color:red'>;</span></p>

<p> // A.4.1.3 Program instantiation</p>

<p>program_instantiation ::=</p>

<p>program_identifier [ parameter_value_assignment ]
hierarchical_instance { <span style='color:red'>, </span>hierarchical_instance
} <span style='color:red'>;</span></p>

<p> // A.4.1.4 Checker instantiation</p>

<p>checker_instantiation ::=</p>

<p>ps_checker_identifier name_of_instance <span
style='color:red'>( </span>[list_of_checker_port_connections] <span
style='color:red'>) ;</span></p>

<p>list_of_checker_port_connections<span style='color:blue;
position:relative;top:-4.0pt'>29 </span>::=</p>

<p>ordered_checker_port_connection { <span style='color:red'>,
</span>ordered_checker_port_connection }</p>

<p>| named_checker_port_connection { <span style='color:red'>,
</span>named_checker_port_connection }</p>

<p>ordered_checker_port_connection ::= { attribute_instance } [
property_actual_arg ]</p>

<p>named_checker_port_connection ::=</p>

<p>{ attribute_instance } <span style='color:red'>. </span>formal_port_identifier
[ <span style='color:red'>( </span>[ property_actual_arg ] <span
style='color:red'>) </span>]</p>

<p>| { attribute_instance } <span style='color:red'>.*</span></p>

<p> // A.4.2 Generated instantiation</p>

<p>generate_region ::=</p>

<p><span style='color:red'>generate </span>{ generate_item
} <span style='color:red'>endgenerate</span></p>

<p>loop_generate_construct ::=</p>

<p><span style='color:red'>for ( </span>genvar_initialization
<span style='color:red'>; </span>genvar_expression <span style='color:red'>;
</span>genvar_iteration <span style='color:red'>)</span></p>

<p>generate_block genvar_initialization ::=</p>

<p>[ <span style='color:red'>genvar </span>]
genvar_identifier <span style='color:red'>= </span>constant_expression</p>

<p>genvar_iteration ::=</p>

<p>genvar_identifier assignment_operator genvar_expression</p>

<p>  | inc_or_dec_operator genvar_identifier</p>

<p>| genvar_identifier inc_or_dec_operator</p>

<p>conditional_generate_construct ::= if_generate_construct</p>

<p>| case_generate_construct</p>

 

 

 

 

 

<p>if_generate_construct ::=</p>

<p><span style='color:red'>if ( </span>constant_expression <span
style='color:red'>) </span>generate_block [ <span style='color:red'>else
</span>generate_block ] case_generate_construct ::=</p>

<p><span style='color:red'>case ( </span>constant_expression
<span style='color:red'>) </span>case_generate_item { case_generate_item } <span
style='color:red'>endcase</span></p>

<p>case_generate_item ::=</p>

<p>constant_expression { <span style='color:red'>, </span>constant_expression
} <span style='color:red'>: </span>generate_block</p>

<p>| <span style='color:red'>default </span>[ <span
style='color:red'>: </span>] generate_block</p>

<p>generate_block ::= generate_item</p>

<p>| [ generate_block_identifier <span style='color:red'>: </span>]
<span style='color:red'>begin </span>[ <span style='color:red'>: </span>generate_block_identifier
] { generate_item }</p>

<p><span style='color:red'>end </span>[ <span
style='color:red'>: </span>generate_block_identifier ]</p>

<p>generate_item<span style='color:blue;position:relative;
top:-4.0pt'>30 </span>::= module_or_generate_item</p>

<p>| interface_or_generate_item</p>

<p>| checker_or_generate_item</p>

<p> // A.5 UDP declaration and instantiation  // A.5.1 UDP
declaration</p>

<p>udp_nonansi_declaration ::= {attribute_instance}<span
style='color:red'>primitive</span>udp_identifier<span style='color:red'>(</span>udp_port_list<span
style='color:red'>) ;</span></p>

<p>udp_ansi_declaration ::= {attribute_instance}<span
style='color:red'>primitive</span>udp_identifier<span style='color:red'>(</span>udp_declaration_port_list<span
style='color:red'>) ;</span></p>

<p>udp_declaration ::=</p>

<p>udp_nonansi_declaration udp_port_declaration {
udp_port_declaration }</p>

<p>udp_body</p>

<p><span style='color:red'>endprimitive </span>[ <span
style='color:red'>: </span>udp_identifier ]</p>

<p>| udp_ansi_declaration udp_body</p>

<p><span style='color:red'>endprimitive </span>[ <span
style='color:red'>: </span>udp_identifier ]</p>

<p>| <span style='color:red'>extern </span>udp_nonansi_declaration</p>

<p>| <span style='color:red'>extern </span>udp_ansi_declaration</p>

<p>| { attribute_instance } <span style='color:red'>primitive
</span>udp_identifier <span style='color:red'>( .* ) ;</span></p>

<p>{ udp_port_declaration }</p>

<p>udp_body</p>

<p><span style='color:red'>endprimitive </span>[ <span
style='color:red'>: </span>udp_identifier ]</p>

<p> // A.5.2 UDP ports</p>

<p>udp_port_list ::= output_port_identifier <span
style='color:red'>, </span>input_port_identifier { <span style='color:red'>,
</span>input_port_identifier }</p>

<p>udp_declaration_port_list ::= udp_output_declaration <span
style='color:red'>, </span>udp_input_declaration { <span style='color:red'>,
</span>udp_input_declaration }</p>

<p>udp_port_declaration ::= udp_output_declaration <span
style='color:red'>;</span></p>

<p>| udp_input_declaration <span style='color:red'>;</span></p>

<p>| udp_reg_declaration <span style='color:red'>;</span></p>

<p>udp_output_declaration ::=</p>

<p>{ attribute_instance } <span style='color:red'>output </span>port_identifier</p>

 

 

<p>  </p>

 

 

<p>| { attribute_instance } <span style='color:red'>output
reg </span>port_identifier [ <span style='color:red'>= </span>constant_expression
] udp_input_declaration ::= { attribute_instance } <span style='color:red'>input
</span>list_of_udp_port_identifiers udp_reg_declaration ::= { attribute_instance
} <span style='color:red'>reg </span>variable_identifier</p>

<p> // A.5.3 UDP body</p>

<p>udp_body ::= combinational_body | sequential_body</p>

<p>combinational_body ::= <span style='color:red'>table </span>combinational_entry
{ combinational_entry } <span style='color:red'>endtable </span>combinational_entry
::= level_input_list <span style='color:red'>: </span>output_symbol <span
style='color:red'>;</span></p>

<p>sequential_body ::= [ udp_initial_statement ] <span
style='color:red'>table </span>sequential_entry { sequential_entry } <span
style='color:red'>endtable </span>udp_initial_statement ::= <span
style='color:red'>initial </span>output_port_identifier <span
style='color:red'>= </span>init_val <span style='color:red'>;</span></p>

<p>init_val ::= <span style='color:red'>1'b0 </span>| <span
style='color:red'>1'b1 </span>| <span style='color:red'>1'bx </span>| <span
style='color:red'>1'bX </span>| <span style='color:red'>1'B0 </span>| <span
style='color:red'>1'B1 </span>| <span style='color:red'>1'Bx </span>| <span
style='color:red'>1'BX </span>| <span style='color:red'>1 </span>| <span
style='color:red'>0</span></p>

<p>sequential_entry ::= seq_input_list <span style='color:red'>:
</span>current_state <span style='color:red'>: </span>next_state <span
style='color:red'>;</span></p>

<p>seq_input_list ::= level_input_list | edge_input_list</p>

<p>level_input_list ::= level_symbol { level_symbol }</p>

<p>edge_input_list ::= { level_symbol } edge_indicator {
level_symbol }</p>

<p>edge_indicator ::= <span style='color:red'>( </span>level_symbol
level_symbol <span style='color:red'>) </span>| edge_symbol</p>

<p>current_state ::= level_symbol</p>

<p>next_state ::= output_symbol | <span style='color:red'>-</span></p>

<p>output_symbol ::= <span style='color:red'>0 </span>| <span
style='color:red'>1 </span>| <span style='color:red'>x </span>| <span
style='color:red'>X</span></p>

<p>level_symbol ::= <span style='color:red'>0 </span>| <span
style='color:red'>1 </span>| <span style='color:red'>x </span>| <span
style='color:red'>X </span>| <span style='color:red'>? </span>| <span
style='color:red'>b </span>| <span style='color:red'>B</span></p>

<p>edge_symbol ::= <span style='color:red'>r </span>| <span
style='color:red'>R </span>| <span style='color:red'>f </span>| <span
style='color:red'>F </span>| <span style='color:red'>p </span>| <span
style='color:red'>P </span>| <span style='color:red'>n </span>| <span
style='color:red'>N </span>| <span style='color:red'>*</span></p>

<p> // A.5.4 UDP instantiation</p>

<p>udp_instantiation ::= udp_identifier [ drive_strength ] [
delay2 ] udp_instance { <span style='color:red'>, </span>udp_instance } <span
style='color:red'>; </span>udp_instance ::= [ name_of_instance ] <span
style='color:red'>( </span>output_terminal <span style='color:red'>, </span>input_terminal
{ <span style='color:red'>, </span>input_terminal } <span style='color:
red'>)</span></p>

<p> // A.6 Behavioral statements</p>

<p> // A.6.1 Continuous assignment and net alias statements</p>

<p>continuous_assign ::=</p>

<p><span style='color:red'>assign </span>[ drive_strength ]
[ delay3 ] list_of_net_assignments <span style='color:red'>;</span></p>

<p>| <span style='color:red'>assign </span>[ delay_control
] list_of_variable_assignments <span style='color:red'>; </span>list_of_net_assignments
::= net_assignment { <span style='color:red'>, </span>net_assignment }
list_of_variable_assignments ::= variable_assignment { <span style='color:red'>,
</span>variable_assignment } net_alias ::= <span style='color:red'>alias </span>net_lvalue
<span style='color:red'>= </span>net_lvalue { <span style='color:red'>=
</span>net_lvalue } <span style='color:red'>;</span></p>

<p>net_assignment ::= net_lvalue <span style='color:red'>= </span>expression</p>

 

 

 

 

 

<p> // A.6.2 Procedural blocks and assignments</p>

<p>initial_construct ::= <span style='color:red'>initial </span>statement_or_null</p>

<p>always_construct ::= always_keyword statement</p>

<p>always_keyword ::= <span style='color:red'>always </span>|
<span style='color:red'>always_comb </span>| <span style='color:red'>always_latch
</span>| <span style='color:red'>always_ff </span>final_construct ::= <span
style='color:red'>final </span>function_statement</p>

<p>blocking_assignment ::=</p>

<p>variable_lvalue <span style='color:red'>= </span>delay_or_event_control
expression</p>

<p>| nonrange_variable_lvalue <span style='color:red'>= </span>dynamic_array_new</p>

<p>| [ implicit_class_handle <span style='color:red'>. </span>|
class_scope | package_scope ] hierarchical_variable_identifier</p>

<p>select <span style='color:red'>= </span>class_new</p>

<p>| operator_assignment</p>

<p>operator_assignment ::= variable_lvalue assignment_operator
expression assignment_operator ::=</p>

<p><span style='color:red'>= </span>| <span
style='color:red'>+= </span>| <span style='color:red'>-= </span>| <span
style='color:red'>*= </span>| <span style='color:red'>/= </span>| <span
style='color:red'>%= </span>| <span style='color:red'>&amp;= </span>| <span
style='color:red'>|= </span>| <span style='color:red'>^= </span>| <span
style='color:red'>&lt;&lt;= </span>| <span style='color:red'>&gt;&gt;= </span>|
<span style='color:red'>&lt;&lt;&lt;= </span>| <span style='color:red'>&gt;&gt;&gt;=
</span>nonblocking_assignment ::=</p>

<p>variable_lvalue <span style='color:red'>&lt;= </span>[
delay_or_event_control ] expression</p>

<p>procedural_continuous_assignment ::= <span style='color:
red'>assign </span>variable_assignment</p>

<p>| <span style='color:red'>deassign </span>variable_lvalue
| <span style='color:red'>force </span>variable_assignment | <span
style='color:red'>force </span>net_assignment</p>

<p>| <span style='color:red'>release </span>variable_lvalue</p>

<p>| <span style='color:red'>release </span>net_lvalue</p>

<p>variable_assignment ::= variable_lvalue <span
style='color:red'>= </span>expression  // A.6.3 Parallel and sequential
blocks</p>

<p>action_block ::= statement_or_null</p>

<p>| [ statement ] <span style='color:red'>else </span>statement_or_null</p>

<p>seq_block ::=</p>

<p><span style='color:red'>begin </span>[ <span
style='color:red'>: </span>block_identifier ] { block_item_declaration } {
statement_or_null } <span style='color:red'>end </span>[ <span
style='color:red'>: </span>block_identifier ]</p>

<p>par_block ::=</p>

<p><span style='color:red'>fork </span>[ <span
style='color:red'>: </span>block_identifier ] { block_item_declaration } {
statement_or_null } join_keyword [ <span style='color:red'>: </span>block_identifier
]</p>

<p>join_keyword ::= <span style='color:red'>join </span>| <span
style='color:red'>join_any </span>| <span style='color:red'>join_none </span> //
A.6.4 Statements</p>

<p>statement_or_null ::= statement</p>

<p>| { attribute_instance } <span style='color:red'>;</span></p>

<p>statement ::= [ block_identifier <span style='color:red'>:
</span>] { attribute_instance } statement_item</p>

<p>statement_item ::= blocking_assignment <span
style='color:red'>;</span></p>

<p>| nonblocking_assignment <span style='color:red'>;</span></p>

<p>| procedural_continuous_assignment <span style='color:red'>;</span></p>

 

 

 

 

 

<p>| case_statement</p>

<p>| conditional_statement</p>

<p>| inc_or_dec_expression <span style='color:red'>;</span></p>

<p>| subroutine_call_statement</p>

<p>| disable_statement</p>

<p>| event_trigger</p>

<p>| loop_statement</p>

<p>| jump_statement</p>

<p>| par_block</p>

<p>| procedural_timing_control_statement | seq_block</p>

<p>| wait_statement</p>

<p>| procedural_assertion_statement</p>

<p>| clocking_drive <span style='color:red'>;</span></p>

<p>| randsequence_statement</p>

<p>| randcase_statement</p>

<p>| expect_property_statement</p>

<p>function_statement ::= statement</p>

<p>function_statement_or_null ::= function_statement</p>

<p>| { attribute_instance } <span style='color:red'>;</span></p>

<p>variable_identifier_list ::= variable_identifier { <span
style='color:red'>, </span>variable_identifier }</p>

<p> // A.6.5 Timing control statements</p>

<p>procedural_timing_control_statement ::=
procedural_timing_control statement_or_null</p>

<p>delay_or_event_control ::= delay_control</p>

<p>| event_control</p>

<p>| <span style='color:red'>repeat ( </span>expression <span
style='color:red'>) </span>event_control</p>

<p>delay_control ::= <span style='color:red'># </span>delay_value</p>

<p>| <span style='color:red'># ( </span>mintypmax_expression
<span style='color:red'>)</span></p>

<p>event_control ::=</p>

<p><span style='color:red'>@ </span>hierarchical_event_identifier</p>

<p>| <span style='color:red'>@ ( </span>event_expression <span
style='color:red'>)</span></p>

<p>| <span style='color:red'>@*</span></p>

<p>| <span style='color:red'>@ (*)</span></p>

<p>| <span style='color:red'>@ </span>ps_or_hierarchical_sequence_identifier</p>

<p>event_expression<span style='color:blue;position:relative;
top:-4.0pt'>31 </span>::=</p>

<p>[ edge_identifier ] expression [ <span style='color:red'>iff
</span>expression ]</p>

<p> | sequence_instance [ <span style='color:red'>iff </span>expression
]</p>

<p>| event_expression <span style='color:red'>or </span>event_expression</p>

<p>| event_expression <span style='color:red'>, </span>event_expression</p>

<p>| <span style='color:red'>( </span>event_expression <span
style='color:red'>)</span></p>

<p>procedural_timing_control ::= delay_control</p>

<p>| event_control</p>

<p>| cycle_delay</p>

<p>jump_statement ::=</p>

 

 

 

 

 

<p><span style='color:red'>return </span>[ expression ] <span
style='color:red'>; </span>| <span style='color:red'>break ;</span></p>

<p>| <span style='color:red'>continue ;</span></p>

<p>wait_statement ::=</p>

<p><span style='color:red'>wait (</span>expression<span
style='color:red'>)</span>statement_or_null</p>

<p>| <span style='color:red'>wait fork ;</span></p>

<p>| <span style='color:red'>wait_order ( </span>hierarchical_identifier
{ <span style='color:red'>, </span>hierarchical_identifier } <span
style='color:red'>) </span>action_block</p>

<p>event_trigger ::=</p>

<p><span style='color:red'>-&gt; </span>hierarchical_event_identifier
<span style='color:red'>;</span></p>

<p>|<span style='color:red'>-&gt;&gt; </span>[
delay_or_event_control ] hierarchical_event_identifier <span style='color:red'>;</span></p>

<p>disable_statement ::=</p>

<p><span style='color:red'>disable </span>hierarchical_task_identifier
<span style='color:red'>;</span></p>

<p>| <span style='color:red'>disable </span>hierarchical_block_identifier
<span style='color:red'>; </span>| <span style='color:red'>disable fork
;</span></p>

<p> // A.6.6 Conditional statements</p>

<p>conditional_statement ::=</p>

<p>[ unique_priority ] <span style='color:red'>if ( </span>cond_predicate
<span style='color:red'>) </span>statement_or_null</p>

<p>{<span style='color:red'>else if ( </span>cond_predicate
<span style='color:red'>) </span>statement_or_null } [ <span
style='color:red'>else </span>statement_or_null ]</p>

<p>unique_priority ::= <span style='color:red'>unique </span>|
<span style='color:red'>unique0 </span>| <span style='color:red'>priority
</span>cond_predicate ::=</p>

<p>expression_or_cond_pattern { <span style='color:red'>&amp;&amp;&amp;
</span>expression_or_cond_pattern } expression_or_cond_pattern ::=</p>

<p>expression | cond_pattern</p>

<p>cond_pattern ::= expression <span style='color:red'>matches
</span>pattern</p>

<p> // A.6.7 Case statements</p>

<p>case_statement ::=</p>

<p>[ unique_priority ] case_keyword <span style='color:red'>(
</span>case_expression <span style='color:red'>)</span></p>

<p>case_item { case_item } <span style='color:red'>endcase</span></p>

<p>| [ unique_priority ] case_keyword <span style='color:red'>(</span>case_expression
<span style='color:red'>)matches</span></p>

<p>case_pattern_item { case_pattern_item } <span
style='color:red'>endcase</span></p>

<p>| [ unique_priority ] <span style='color:red'>case ( </span>case_expression
<span style='color:red'>) inside</span></p>

<p>case_inside_item { case_inside_item } <span
style='color:red'>endcase </span>case_keyword ::= <span style='color:red'>case
</span>| <span style='color:red'>casez </span>| <span style='color:red'>casex
</span>case_expression ::= expression</p>

<p>case_item ::=</p>

<p>case_item_expression { <span style='color:red'>, </span>case_item_expression
} <span style='color:red'>: </span>statement_or_null</p>

<p>| <span style='color:red'>default </span>[ <span
style='color:red'>: </span>] statement_or_null</p>

<p>case_pattern_item ::=</p>

<p>pattern [ <span style='color:red'>&amp;&amp;&amp; </span>expression
] <span style='color:red'>: </span>statement_or_null</p>

<p>| <span style='color:red'>default </span>[ <span
style='color:red'>: </span>] statement_or_null</p>

<p>case_inside_item ::=</p>

<p>open_range_list <span style='color:red'>: </span>statement_or_null</p>

<p>| <span style='color:red'>default </span>[ <span
style='color:red'>: </span>] statement_or_null case_item_expression ::=
expression</p>

 

 

 

 

 

<p>randcase_statement ::=</p>

<p><span style='color:red'>randcase </span>randcase_item {
randcase_item } <span style='color:red'>endcase </span>randcase_item ::=
expression <span style='color:red'>: </span>statement_or_null
open_range_list ::= open_value_range { <span style='color:red'>, </span>open_value_range
}</p>

<p>open_value_range ::= value_range<span style='color:blue;
position:relative;top:-4.0pt'>25 </span> // A.6.7.1 Patterns</p>

<p>pattern ::=</p>

<p><span style='color:red'>. </span>variable_identifier</p>

<p>| <span style='color:red'>.*</span></p>

<p>| constant_expression</p>

<p>| <span style='color:red'>tagged </span>member_identifier
[ pattern ]</p>

<p>| <span style='color:red'>'{ </span>pattern { <span
style='color:red'>, </span>pattern } <span style='color:red'>}</span></p>

<p>| <span style='color:red'>'{ </span>member_identifier <span
style='color:red'>: </span>pattern { <span style='color:red'>, </span>member_identifier
<span style='color:red'>: </span>pattern } <span style='color:red'>}</span></p>

<p>assignment_pattern ::=</p>

<p><span style='color:red'>'{ </span>expression { <span
style='color:red'>, </span>expression } <span style='color:red'>}</span></p>

<p>| <span style='color:red'>'{ </span>structure_pattern_key
<span style='color:red'>: </span>expression { <span style='color:red'>,
</span>structure_pattern_key <span style='color:red'>: </span>expression } <span
style='color:red'>} </span>| <span style='color:red'>'{ </span>array_pattern_key
<span style='color:red'>: </span>expression { <span style='color:red'>,
</span>array_pattern_key <span style='color:red'>: </span>expression } <span
style='color:red'>}</span></p>

<p>| <span style='color:red'>'{ </span>constant_expression <span
style='color:red'>{ </span>expression { <span style='color:red'>, </span>expression
} <span style='color:red'>} }</span></p>

<p>structure_pattern_key ::= member_identifier |
assignment_pattern_key array_pattern_key ::= constant_expression |
assignment_pattern_key assignment_pattern_key ::= simple_type | <span
style='color:red'>default </span>assignment_pattern_expression ::=</p>

<p>[ assignment_pattern_expression_type ] assignment_pattern</p>

<p>assignment_pattern_expression_type ::= ps_type_identifier</p>

<p>| ps_parameter_identifier</p>

<p>| integer_atom_type | type_reference</p>

<p>constant_assignment_pattern_expression<span
style='color:blue;position:relative;top:-4.0pt'>32 </span>::=
assignment_pattern_expression assignment_pattern_net_lvalue ::=</p>

<p><span style='color:red'>'{ </span>net_lvalue {<span
style='color:red'>, </span>net_lvalue } <span style='color:red'>} </span>assignment_pattern_variable_lvalue
::=</p>

<p><span style='color:red'>'{ </span>variable_lvalue {<span
style='color:red'>, </span>variable_lvalue } <span style='color:red'>} </span> //
A.6.8 Looping statements</p>

<p>loop_statement ::=</p>

<p><span style='color:red'>forever </span>statement_or_null</p>

<p>| <span style='color:red'>repeat ( </span>expression <span
style='color:red'>) </span>statement_or_null</p>

<p>| <span style='color:red'>while ( </span>expression <span
style='color:red'>) </span>statement_or_null</p>

<p>| <span style='color:red'>for ( </span>[ for_initialization
] <span style='color:red'>; </span>[ expression ] <span style='color:red'>;
</span>[ for_step ] <span style='color:red'>)</span></p>

<p>statement_or_null</p>

<p>| <span style='color:red'>do </span>statement_or_null <span
style='color:red'>while ( </span>expression <span style='color:red'>) ;</span></p>

<p>| <span style='color:red'>foreach ( </span>ps_or_hierarchical_array_identifier
<span style='color:red'>[ </span>loop_variables <span style='color:red'>]
) </span>statement</p>

<p>for_initialization ::= list_of_variable_assignments</p>

<p>| for_variable_declaration { <span style='color:red'>, </span>for_variable_declaration
} for_variable_declaration ::=</p>

 

 

<p>   </p>

 

 

<p>[ <span style='color:red'>var </span>] data_type
variable_identifier <span style='color:red'>= </span>expression { <span
style='color:red'>, </span>variable_identifier <span style='color:red'>=
</span>expression }<span style='color:blue;position:relative;top:-4.0pt'>14</span></p>

<p>for_step ::= for_step_assignment { <span style='color:red'>,
</span>for_step_assignment }</p>

<p>for_step_assignment ::= operator_assignment</p>

<p>| inc_or_dec_expression</p>

<p>| function_subroutine_call</p>

<p>loop_variables ::= [ index_variable_identifier ] { <span
style='color:red'>, </span>[ index_variable_identifier ] }</p>

<p> // A.6.9 Subroutine call statements</p>

<p>subroutine_call_statement ::= subroutine_call <span
style='color:red'>;</span></p>

<p>| <span style='color:red'>void ' ( </span>function_subroutine_call
<span style='color:red'>) ;</span></p>

<p> // A.6.10 Assertion statements</p>

<p>assertion_item ::= concurrent_assertion_item</p>

<p>| deferred_immediate_assertion_item</p>

<p>deferred_immediate_assertion_item ::= [ block_identifier <span
style='color:red'>: </span>] deferred_immediate_assertion_statement</p>

<p>procedural_assertion_statement ::=
concurrent_assertion_statement</p>

<p>| immediate_assertion_statement</p>

<p>| checker_instantiation</p>

<p>immediate_assertion_statement ::= simple_immediate_assertion_statement</p>

<p>| deferred_immediate_assertion_statement</p>

<p>simple_immediate_assertion_statement ::=
simple_immediate_assert_statement</p>

<p>| simple_immediate_assume_statement</p>

<p>| simple_immediate_cover_statement</p>

<p>simple_immediate_assert_statement ::= <span
style='color:red'>assert ( </span>expression <span style='color:red'>) </span>action_block</p>

<p>simple_immediate_assume_statement ::= <span
style='color:red'>assume ( </span>expression <span style='color:red'>) </span>action_block</p>

<p>simple_immediate_cover_statement ::= <span style='color:
red'>cover ( </span>expression <span style='color:red'>) </span>statement_or_null</p>

<p>deferred_immediate_assertion_statement ::=
deferred_immediate_assert_statement</p>

<p>| deferred_immediate_assume_statement</p>

<p>| deferred_immediate_cover_statement</p>

<p>deferred_immediate_assert_statement ::= <span
style='color:red'>assert #0 ( </span>expression <span style='color:red'>)
</span>action_block</p>

<p>| <span style='color:red'>assert final ( </span>expression
<span style='color:red'>) </span>action_block</p>

<p>deferred_immediate_assume_statement ::= <span
style='color:red'>assume #0 ( </span>expression <span style='color:red'>)
</span>action_block</p>

<p>| <span style='color:red'>assume final ( </span>expression
<span style='color:red'>) </span>action_block</p>

<p>deferred_immediate_cover_statement ::=</p>

<p><span style='color:red'>cover #0 ( </span>expression <span
style='color:red'>) </span>statement_or_null</p>

<p>| <span style='color:red'>cover final ( </span>expression
<span style='color:red'>) </span>statement_or_null  </p>

 

<p>  </p>

 

 

<p> // A.6.11 Clocking block</p>

<p>clocking_declaration ::= [ <span style='color:red'>default
</span>] <span style='color:red'>clocking </span>[ clocking_identifier ]
clocking_event <span style='color:red'>; </span>{ clocking_item }</p>

<p><span style='color:red'>endclocking </span>[ <span
style='color:red'>: </span>clocking_identifier ]</p>

<p>| <span style='color:red'>global clocking </span>[
clocking_identifier ] clocking_event <span style='color:red'>; endclocking </span>[
<span style='color:red'>: </span>clocking_identifier ]</p>

<p>clocking_event ::= <span style='color:red'>@ </span>identifier</p>

<p>| <span style='color:red'>@ ( </span>event_expression <span
style='color:red'>)</span></p>

<p>clocking_item ::=</p>

<p><span style='color:red'>default </span>default_skew <span
style='color:red'>;</span></p>

<p>| clocking_direction list_of_clocking_decl_assign <span
style='color:red'>; </span>| { attribute_instance }
assertion_item_declaration</p>

<p>default_skew ::=</p>

<p><span style='color:red'>input </span>clocking_skew</p>

<p>| <span style='color:red'>output </span>clocking_skew</p>

<p>| <span style='color:red'>input </span>clocking_skew <span
style='color:red'>output </span>clocking_skew</p>

<p>clocking_direction ::=</p>

<p><span style='color:red'>input </span>[ clocking_skew ]</p>

<p>| <span style='color:red'>output </span>[ clocking_skew
]</p>

<p>| <span style='color:red'>input </span>[ clocking_skew ]
<span style='color:red'>output </span>[ clocking_skew ] | <span
style='color:red'>inout</span></p>

<p>list_of_clocking_decl_assign ::= clocking_decl_assign { <span
style='color:red'>, </span>clocking_decl_assign }</p>

<p>clocking_decl_assign ::= signal_identifier [ <span
style='color:red'>= </span>expression ]</p>

<p>clocking_skew ::=</p>

<p>edge_identifier [ delay_control ]</p>

<p>| delay_control clocking_drive ::=</p>

<p>clockvar_expression <span style='color:red'>&lt;= </span>[
cycle_delay ] expression</p>

<p>cycle_delay ::=</p>

<p><span style='color:red'>## </span>integral_number</p>

<p>| <span style='color:red'>## </span>identifier</p>

<p>| <span style='color:red'>## ( </span>expression <span
style='color:red'>)</span></p>

<p>clockvar ::= hierarchical_identifier clockvar_expression ::=
clockvar select</p>

<p> // A.6.12 Randsequence</p>

<p>randsequence_statement::=<span style='color:red'>randsequence
(</span>[production_identifier]<span style='color:red'>) </span>production
{ production }</p>

<p><span style='color:red'>endsequence</span></p>

<p>production ::= [ data_type_or_void ] production_identifier [
<span style='color:red'>( </span>tf_port_list <span style='color:red'>)
</span>] <span style='color:red'>: </span>rs_rule { <span style='color:
red'>| </span>rs_rule } <span style='color:red'>; </span>rs_rule ::=
rs_production_list [ <span style='color:red'>:= </span>weight_specification
[ rs_code_block ] ]</p>

<p>rs_production_list ::= rs_prod { rs_prod }</p>

<p>| <span style='color:red'>rand join </span>[ <span
style='color:red'>( </span>expression <span style='color:red'>) </span>]
production_item production_item { production_item }</p>

<p>weight_specification ::= integral_number</p>

<p>| ps_identifier</p>

 

 

 

 

 

<p>| <span style='color:red'>( </span>expression <span
style='color:red'>)</span></p>

<p>rs_code_block ::= <span style='color:red'>{ </span>{
data_declaration } { statement_or_null } <span style='color:red'>}</span></p>

<p>rs_prod ::= production_item</p>

<p>| rs_code_block</p>

<p>| rs_if_else</p>

<p>| rs_repeat</p>

<p>| rs_case</p>

<p>production_item ::= production_identifier [ <span
style='color:red'>( </span>list_of_arguments <span style='color:red'>) </span>]
rs_if_else::=<span style='color:red'>if (</span>expression<span
style='color:red'>)</span>production_item[<span style='color:red'>else</span>production_item]
rs_repeat::=<span style='color:red'>repeat (</span>expression<span
style='color:red'>)</span>production_item</p>

<p>rs_case::=<span style='color:red'>case (</span>case_expression<span
style='color:red'>)</span>rs_case_item{rs_case_item}<span style='color:
red'>endcase</span></p>

<p>rs_case_item ::=</p>

<p>case_item_expression { <span style='color:red'>, </span>case_item_expression
} <span style='color:red'>: </span>production_item <span style='color:red'>;</span></p>

<p>| <span style='color:red'>default </span>[ <span
style='color:red'>: </span>] production_item <span style='color:red'>; </span> </p>

<p>&nbsp;</p>

<p>// A.7 Specify section</p>

<p> // A.7.1 Specify block declaration</p>

<p>specify_block ::= <span style='color:red'>specify </span>{
specify_item } <span style='color:red'>endspecify</span></p>

<p>specify_item ::= specparam_declaration</p>

<p>| pulsestyle_declaration</p>

<p>| showcancelled_declaration</p>

<p>| path_declaration</p>

<p>| system_timing_check</p>

<p>pulsestyle_declaration ::=</p>

<p><span style='color:red'>pulsestyle_onevent </span>list_of_path_outputs
<span style='color:red'>;</span></p>

<p>| <span style='color:red'>pulsestyle_ondetect </span>list_of_path_outputs
<span style='color:red'>;</span></p>

<p>showcancelled_declaration ::= <span style='color:red'>showcancelled
</span>list_of_path_outputs <span style='color:red'>;</span></p>

<p>| <span style='color:red'>noshowcancelled </span>list_of_path_outputs
<span style='color:red'>; </span> </p>

<p>// A.7.2 Specify path declarations</p>

<p>path_declaration ::= simple_path_declaration <span
style='color:red'>;</span></p>

<p>| edge_sensitive_path_declaration <span style='color:red'>;</span></p>

<p>| state_dependent_path_declaration <span style='color:red'>;</span></p>

<p>simple_path_declaration ::= parallel_path_description <span
style='color:red'>= </span>path_delay_value</p>

<p>| full_path_description <span style='color:red'>= </span>path_delay_value
parallel_path_description ::=</p>

<p><span style='color:red'>( </span>specify_input_terminal_descriptor
[ polarity_operator ] <span style='color:red'>=&gt; </span>specify_output_terminal_descriptor
<span style='color:red'>) </span>full_path_description ::=</p>

<p><span style='color:red'>( </span>list_of_path_inputs [
polarity_operator ] <span style='color:red'>*&gt; </span>list_of_path_outputs
<span style='color:red'>) </span>list_of_path_inputs ::=</p>

 

 

 

 

 

<p>specify_input_terminal_descriptor { <span style='color:red'>,
</span>specify_input_terminal_descriptor } list_of_path_outputs ::=</p>

<p>specify_output_terminal_descriptor { <span style='color:
red'>, </span>specify_output_terminal_descriptor }  </p>

<p>&nbsp;</p>

<p>// A.7.3 Specify block terminals</p>

<p>specify_input_terminal_descriptor ::=</p>

<p>input_identifier [ <span style='color:red'>[ </span>constant_range_expression
<span style='color:red'>] </span>]</p>

<p>specify_output_terminal_descriptor ::= output_identifier [ <span
style='color:red'>[ </span>constant_range_expression <span
style='color:red'>] </span>]</p>

<p>input_identifier ::= input_port_identifier |
inout_port_identifier | interface_identifier<span style='color:red'>.</span>port_identifier
output_identifier ::= output_port_identifier | inout_port_identifier |
interface_identifier<span style='color:red'>.</span>port_identifier</p>

<p>&nbsp;</p>

<p> // A.7.4 Specify path delays</p>

<p>path_delay_value ::= list_of_path_delay_expressions</p>

<p>| <span style='color:red'>( </span>list_of_path_delay_expressions
<span style='color:red'>)</span></p>

<p>list_of_path_delay_expressions ::= t_path_delay_expression</p>

<p>| trise_path_delay_expression <span style='color:red'>, </span>tfall_path_delay_expression</p>

<p>| trise_path_delay_expression <span style='color:red'>, </span>tfall_path_delay_expression
<span style='color:red'>, </span>tz_path_delay_expression</p>

<p>| t01_path_delay_expression <span style='color:red'>, </span>t10_path_delay_expression
<span style='color:red'>, </span>t0z_path_delay_expression <span
style='color:red'>,</span></p>

<p>tz1_path_delay_expression <span style='color:red'>, </span>t1z_path_delay_expression
<span style='color:red'>, </span>tz0_path_delay_expression</p>

<p>| t01_path_delay_expression <span style='color:red'>, </span>t10_path_delay_expression
<span style='color:red'>, </span>t0z_path_delay_expression <span
style='color:red'>,</span></p>

<p>tz1_path_delay_expression <span style='color:red'>, </span>t1z_path_delay_expression
<span style='color:red'>, </span>tz0_path_delay_expression <span
style='color:red'>, </span>t0x_path_delay_expression <span
style='color:red'>, </span>tx1_path_delay_expression <span
style='color:red'>, </span>t1x_path_delay_expression <span
style='color:red'>, </span>tx0_path_delay_expression <span
style='color:red'>, </span>txz_path_delay_expression <span
style='color:red'>, </span>tzx_path_delay_expression</p>

<p>t_path_delay_expression ::= path_delay_expression</p>

<p>trise_path_delay_expression ::= path_delay_expression</p>

<p>tfall_path_delay_expression ::= path_delay_expression</p>

<p>tz_path_delay_expression ::= path_delay_expression</p>

<p>t01_path_delay_expression ::= path_delay_expression</p>

<p>t10_path_delay_expression ::= path_delay_expression</p>

<p>t0z_path_delay_expression ::= path_delay_expression</p>

<p>tz1_path_delay_expression ::= path_delay_expression</p>

<p>t1z_path_delay_expression ::= path_delay_expression</p>

<p>tz0_path_delay_expression ::= path_delay_expression</p>

<p>t0x_path_delay_expression ::= path_delay_expression</p>

<p>tx1_path_delay_expression ::= path_delay_expression</p>

<p>t1x_path_delay_expression ::= path_delay_expression</p>

<p>tx0_path_delay_expression ::= path_delay_expression</p>

<p>txz_path_delay_expression ::= path_delay_expression</p>

<p>tzx_path_delay_expression ::= path_delay_expression</p>

<p>path_delay_expression ::= constant_mintypmax_expression</p>

<p>edge_sensitive_path_declaration ::=
parallel_edge_sensitive_path_description <span style='color:red'>= </span>path_delay_value</p>

 

 

 

 

 

<p>| full_edge_sensitive_path_description <span
style='color:red'>= </span>path_delay_value</p>

<p>parallel_edge_sensitive_path_description ::=</p>

<p><span style='color:red'>( </span>[ edge_identifier ]
specify_input_terminal_descriptor [ polarity_operator ] <span style='color:
red'>=&gt;</span></p>

<p><span style='color:red'>( </span>specify_output_terminal_descriptor
[ polarity_operator ] <span style='color:red'>: </span>data_source_expression
<span style='color:red'>) )</span></p>

<p>full_edge_sensitive_path_description ::=</p>

<p><span style='color:red'>( </span>[ edge_identifier ]
list_of_path_inputs [ polarity_operator ] <span style='color:red'>*&gt;</span></p>

<p><span style='color:red'>( </span>list_of_path_outputs [
polarity_operator ] <span style='color:red'>: </span>data_source_expression
<span style='color:red'>) ) </span>data_source_expression ::= expression</p>

<p>edge_identifier ::= <span style='color:red'>posedge </span>|
<span style='color:red'>negedge </span>| <span style='color:red'>edge</span></p>

<p>state_dependent_path_declaration ::=</p>

<p><span style='color:red'>if ( </span>module_path_expression
<span style='color:red'>) </span>simple_path_declaration</p>

<p>| <span style='color:red'>if ( </span>module_path_expression
<span style='color:red'>) </span>edge_sensitive_path_declaration | <span
style='color:red'>ifnone </span>simple_path_declaration</p>

<p>polarity_operator ::= <span style='color:red'>+ </span>|
<span style='color:red'>-</span></p>

<p><span style='color:red'>&nbsp;</span></p>

<p> // A.7.5 System timing checks</p>

<p> // A.7.5.1 System timing check commands</p>

<p>system_timing_check ::= $setup_timing_check</p>

<p>| $hold_timing_check</p>

<p>| $setuphold_timing_check</p>

<p>| $recovery_timing_check</p>

<p>| $removal_timing_check</p>

<p>| $recrem_timing_check</p>

<p>| $skew_timing_check</p>

<p>| $timeskew_timing_check</p>

<p>| $fullskew_timing_check</p>

<p>| $period_timing_check</p>

<p>| $width_timing_check</p>

<p>| $nochange_timing_check</p>

<p>$setup_timing_check ::=</p>

<p><span style='color:red'>$setup (</span>data_event<span
style='color:red'>,</span>reference_event<span style='color:red'>,</span>timing_check_limit[<span
style='color:red'>,</span>[notifier]]<span style='color:red'>) ;</span></p>

<p>$hold_timing_check ::=</p>

<p><span style='color:red'>$hold (</span>reference_event<span
style='color:red'>,</span>data_event<span style='color:red'>,</span>timing_check_limit[<span
style='color:red'>,</span>[notifier]]<span style='color:red'>) ;</span></p>

<p>$setuphold_timing_check ::=</p>

<p><span style='color:red'>$setuphold (</span>reference_event<span
style='color:red'>,</span>data_event<span style='color:red'>,</span>timing_check_limit<span
style='color:red'>,</span>timing_check_limit</p>

<p>[ <span style='color:red'>, </span>[ notifier ] [ <span
style='color:red'>, </span>[ timestamp_condition ] [ <span
style='color:red'>, </span>[ timecheck_condition ] [<span style='color:
red'>,</span>[delayed_reference][<span style='color:red'>,</span>[delayed_data]]]]]]<span
style='color:red'>) ;</span></p>

<p>$recovery_timing_check ::=</p>

<p><span style='color:red'>$recovery (</span>reference_event<span
style='color:red'>,</span>data_event<span style='color:red'>,</span>timing_check_limit[<span
style='color:red'>,</span>[notifier]]<span style='color:red'>) ;</span></p>

<p>$removal_timing_check ::=</p>

<p><span style='color:red'>$removal (</span>reference_event<span
style='color:red'>,</span>data_event<span style='color:red'>,</span>timing_check_limit[<span
style='color:red'>,</span>[notifier]]<span style='color:red'>) ;</span></p>

<p>$recrem_timing_check ::=</p>

<p><span style='color:red'>$recrem (</span>reference_event<span
style='color:red'>,</span>data_event<span style='color:red'>,</span>timing_check_limit<span
style='color:red'>,</span>timing_check_limit</p>

<p>[ <span style='color:red'>, </span>[ notifier ] [ <span
style='color:red'>, </span>[ timestamp_condition ] [ <span
style='color:red'>, </span>[ timecheck_condition ] [<span style='color:
red'>,</span>[delayed_reference][<span style='color:red'>,</span>[delayed_data]]]]]]<span
style='color:red'>) ;</span></p>

<p>$skew_timing_check ::=</p>

<p><span style='color:red'>$skew (</span>reference_event<span
style='color:red'>,</span>data_event<span style='color:red'>,</span>timing_check_limit[<span
style='color:red'>,</span>[notifier]]<span style='color:red'>) ;</span></p>

 

 

 

 

 

<p>$timeskew_timing_check ::=</p>

<p><span style='color:red'>$timeskew (</span>reference_event<span
style='color:red'>,</span>data_event<span style='color:red'>,</span>timing_check_limit
[<span style='color:red'>,</span>[notifier][<span style='color:red'>,</span>[event_based_flag][<span
style='color:red'>,</span>[remain_active_flag]]]]<span style='color:red'>)
;</span></p>

<p>$fullskew_timing_check ::=</p>

<p><span style='color:red'>$fullskew (</span>reference_event<span
style='color:red'>,</span>data_event<span style='color:red'>,</span>timing_check_limit<span
style='color:red'>,</span>timing_check_limit</p>

<p>[<span style='color:red'>,</span>[notifier][<span
style='color:red'>,</span>[event_based_flag][<span style='color:red'>,</span>[remain_active_flag]]]]<span
style='color:red'>) ; </span>$period_timing_check ::=</p>

<p><span style='color:red'>$period (</span>controlled_reference_event<span
style='color:red'>,</span>timing_check_limit[<span style='color:red'>,</span>[notifier]]<span
style='color:red'>) ; </span>$width_timing_check ::=</p>

<p><span style='color:red'>$width (</span>controlled_reference_event<span
style='color:red'>,</span>timing_check_limit<span style='color:red'>,</span>threshold[<span
style='color:red'>,</span>[notifier]]<span style='color:red'>) ; </span>$nochange_timing_check
::=</p>

<p><span style='color:red'>$nochange ( </span>reference_event
<span style='color:red'>, </span>data_event <span style='color:red'>, </span>start_edge_offset
<span style='color:red'>, </span>end_edge_offset [ <span style='color:red'>,
</span>[ notifier ] ] <span style='color:red'>);</span></p>

<p><span style='color:red'>&nbsp;</span></p>

<p> // A.7.5.2 System timing check command arguments</p>

<p>timecheck_condition ::= mintypmax_expression
controlled_reference_event ::= controlled_timing_check_event data_event ::=
timing_check_event</p>

<p>delayed_data ::= terminal_identifier</p>

<p>| terminal_identifier <span style='color:red'>[ </span>constant_mintypmax_expression
<span style='color:red'>]</span></p>

<p>delayed_reference ::= terminal_identifier</p>

<p>| terminal_identifier <span style='color:red'>[ </span>constant_mintypmax_expression
<span style='color:red'>] </span>end_edge_offset ::= mintypmax_expression
event_based_flag ::= constant_expression</p>

<p>notifier ::= variable_identifier</p>

<p>reference_event ::= timing_check_event remain_active_flag
::= constant_mintypmax_expression timestamp_condition ::= mintypmax_expression
start_edge_offset ::= mintypmax_expression</p>

<p>threshold ::= constant_expression</p>

<p>timing_check_limit ::= expression</p>

<p>&nbsp;</p>

<p> // A.7.5.3 System timing check event definitions</p>

<p>timing_check_event ::=</p>

<p>[timing_check_event_control] specify_terminal_descriptor [ <span
style='color:red'>&amp;&amp;&amp; </span>timing_check_condition ]</p>

<p>controlled_timing_check_event ::=</p>

<p>timing_check_event_control specify_terminal_descriptor [ <span
style='color:red'>&amp;&amp;&amp; </span>timing_check_condition ]</p>

<p>timing_check_event_control ::=</p>

<p><span style='color:red'>posedge</span></p>

<p>| <span style='color:red'>negedge</span></p>

<p>| <span style='color:red'>edge</span></p>

<p>| edge_control_specifier</p>

<p>specify_terminal_descriptor ::=
specify_input_terminal_descriptor</p>

<p>| specify_output_terminal_descriptor</p>

<p>edge_control_specifier ::= <span style='color:red'>edge
[ </span>edge_descriptor { <span style='color:red'>, </span>edge_descriptor
} <span style='color:red'>]</span></p>

 

 

 

 

 

<p>edge_descriptor<span style='color:blue;position:relative;
top:-4.0pt'>33 </span>::= <span style='color:red'>01 </span>| <span
style='color:red'>10 </span>| z_or_x zero_or_one | zero_or_one z_or_x
zero_or_one ::= <span style='color:red'>0 </span>| <span style='color:red'>1</span></p>

<p>z_or_x ::= <span style='color:red'>x </span>| <span
style='color:red'>X </span>| <span style='color:red'>z </span>| <span
style='color:red'>Z</span></p>

<p>timing_check_condition ::= scalar_timing_check_condition</p>

<p>| <span style='color:red'>( </span>scalar_timing_check_condition
<span style='color:red'>)</span></p>

<p>scalar_timing_check_condition ::= expression</p>

<p>| <span style='color:red'>~ </span>expression</p>

<p>| expression <span style='color:red'>== </span>scalar_constant</p>

<p>| expression <span style='color:red'>=== </span>scalar_constant</p>

<p>| expression <span style='color:red'>!= </span>scalar_constant</p>

<p>| expression <span style='color:red'>!== </span>scalar_constant</p>

<p>scalar_constant ::= <span style='color:red'>1'b0 </span>|
<span style='color:red'>1'b1 </span>| <span style='color:red'>1'B0 </span>|
<span style='color:red'>1'B1 </span>| <span style='color:red'>'b0 </span>|
<span style='color:red'>'b1 </span>| <span style='color:red'>'B0 </span>|
<span style='color:red'>'B1 </span>| <span style='color:red'>1 </span>|
<span style='color:red'>0 </span> </p>

<p>&nbsp;</p>

<p>// A.8 Expressions</p>

<p> // A.8.1 Concatenations</p>

<p>concatenation ::=</p>

<p><span style='color:red'>{ </span>expression { <span
style='color:red'>, </span>expression } <span style='color:red'>}</span></p>

<p>constant_concatenation ::=</p>

<p><span style='color:red'>{ </span>constant_expression { <span
style='color:red'>, </span>constant_expression } <span style='color:red'>}</span></p>

<p>constant_multiple_concatenation ::= <span style='color:red'>{
</span>constant_expression constant_concatenation <span style='color:red'>}
</span>module_path_concatenation ::= <span style='color:red'>{ </span>module_path_expression
{ <span style='color:red'>, </span>module_path_expression } <span
style='color:red'>} </span>module_path_multiple_concatenation ::= <span
style='color:red'>{ </span>constant_expression module_path_concatenation <span
style='color:red'>}</span></p>

<p>multiple_concatenation ::= <span style='color:red'>{ </span>expression
concatenation <span style='color:red'>}</span><span style='color:blue;
position:relative;top:-4.0pt'>34</span></p>

<p>streaming_concatenation ::= <span style='color:red'>{ </span>stream_operator
[ slice_size ] stream_concatenation <span style='color:red'>} </span>stream_operator
::= <span style='color:red'>&gt;&gt; </span>| <span style='color:red'>&lt;&lt;</span></p>

<p>slice_size ::= simple_type | constant_expression</p>

<p>stream_concatenation ::= <span style='color:red'>{ </span>stream_expression
{ <span style='color:red'>, </span>stream_expression } <span
style='color:red'>} </span>stream_expression ::= expression [ <span
style='color:red'>with [ </span>array_range_expression <span
style='color:red'>] </span>]</p>

<p>array_range_expression ::= expression</p>

<p>| expression <span style='color:red'>: </span>expression</p>

<p>| expression <span style='color:red'>+: </span>expression</p>

<p>| expression <span style='color:red'>-: </span>expression</p>

<p>empty_unpacked_array_concatenation<span style='color:blue;
position:relative;top:-4.0pt'>35 </span>::= <span style='color:red'>{ } </span> </p>

<p>&nbsp;</p>

<p>// A.8.2 Subroutine calls</p>

<p>constant_function_call ::= function_subroutine_call<span
style='color:blue;position:relative;top:-4.0pt'>36</span></p>

<p>tf_call<span style='color:blue;position:relative;top:-4.0pt'>37
</span>::= ps_or_hierarchical_tf_identifier { attribute_instance } [ <span
style='color:red'>( </span>list_of_arguments <span style='color:red'>) </span>]</p>

<p>system_tf_call ::=</p>

<p>system_tf_identifier [ <span style='color:red'>( </span>list_of_arguments
<span style='color:red'>) </span>]</p>

 

 

<p>      </p>

 

 

<p>| system_tf_identifier <span style='color:red'>( </span>data_type
[ <span style='color:red'>, </span>expression ] <span style='color:red'>)</span></p>

<p>| system_tf_identifier <span style='color:red'>( </span>expression
{ <span style='color:red'>, </span>[ expression ] } [ <span
style='color:red'>, </span>[ clocking_event ] ] <span style='color:red'>)</span></p>

<p>subroutine_call ::= tf_call</p>

<p>| system_tf_call</p>

<p>| method_call</p>

<p>| [ <span style='color:red'>std :: </span>]
randomize_call</p>

<p>function_subroutine_call ::= subroutine_call</p>

<p>list_of_arguments ::=</p>

<p>[ expression ] { <span style='color:red'>, </span>[
expression ] } { <span style='color:red'>, . </span>identifier <span
style='color:red'>( </span>[ expression ] <span style='color:red'>) </span>}</p>

<p>| <span style='color:red'>. </span>identifier <span
style='color:red'>( </span>[ expression ] <span style='color:red'>) </span>{
<span style='color:red'>, . </span>identifier <span style='color:red'>(
</span>[ expression ] <span style='color:red'>) </span>}</p>

<p>method_call ::= method_call_root <span style='color:red'>.
</span>method_call_body</p>

<p>method_call_body ::=</p>

<p>method_identifier { attribute_instance } [ <span
style='color:red'>( </span>list_of_arguments <span style='color:red'>) </span>]</p>

<p>| built_in_method_call</p>

<p>built_in_method_call ::= array_manipulation_call</p>

<p>| randomize_call</p>

<p>array_manipulation_call ::= array_method_name {
attribute_instance }</p>

<p>[ <span style='color:red'>( </span>list_of_arguments <span
style='color:red'>) </span>] [ <span style='color:red'>with ( </span>expression
<span style='color:red'>) </span>]</p>

<p>randomize_call ::=</p>

<p><span style='color:red'>randomize </span>{
attribute_instance }</p>

<p>[ <span style='color:red'>( </span>[
variable_identifier_list | <span style='color:red'>null </span>] <span
style='color:red'>) </span>]</p>

<p>[ <span style='color:red'>with </span>[ <span
style='color:red'>( </span>[ identifier_list ] <span style='color:red'>)
</span>] constraint_block ]<span style='color:blue;position:relative;
top:-4.0pt'>38</span></p>

<p>method_call_root ::= primary | implicit_class_handle</p>

<p>array_method_name ::=</p>

<p>method_identifier | <span style='color:red'>unique </span>|
<span style='color:red'>and </span>| <span style='color:red'>or </span>|
<span style='color:red'>xor</span></p>

 

<p>// A.8.3 Expressions</p>

<p>inc_or_dec_expression ::=</p>

<p>inc_or_dec_operator { attribute_instance } variable_lvalue</p>

<p>| variable_lvalue { attribute_instance } inc_or_dec_operator</p>

<p>conditional_expression ::= cond_predicate <span
style='color:red'>? </span>{ attribute_instance } expression <span
style='color:red'>: </span>expression</p>

<p>constant_expression ::= constant_primary</p>

<p>| unary_operator { attribute_instance } constant_primary</p>

<p>| constant_expression binary_operator { attribute_instance }
constant_expression</p>

<p>| constant_expression <span style='color:red'>? </span>{
attribute_instance } constant_expression <span style='color:red'>: </span>constant_expression</p>

<p>constant_mintypmax_expression ::= constant_expression</p>

<p>| constant_expression <span style='color:red'>: </span>constant_expression
<span style='color:red'>: </span>constant_expression
constant_param_expression ::=</p>

<p>constant_mintypmax_expression | data_type | <span
style='color:red'>$</span></p>

<p>param_expression ::= mintypmax_expression | data_type | <span
style='color:red'>$</span></p>

<p><span style='color:red'> </span>constant_range_expression
::= constant_expression</p>

 

 

 

 

 

<p>| constant_part_select_range</p>

<p>constant_part_select_range ::= constant_range</p>

<p>| constant_indexed_range</p>

<p>constant_range ::= constant_expression <span
style='color:red'>: </span>constant_expression</p>

<p>constant_indexed_range ::=</p>

<p>constant_expression <span style='color:red'>+: </span>constant_expression</p>

<p>| constant_expression <span style='color:red'>-: </span>constant_expression</p>

<p>expression ::= primary</p>

<p>| unary_operator { attribute_instance } primary</p>

<p>| inc_or_dec_expression</p>

<p>| <span style='color:red'>( </span>operator_assignment <span
style='color:red'>)</span></p>

<p>| expression binary_operator { attribute_instance }
expression</p>

<p>| conditional_expression</p>

<p>| inside_expression</p>

<p>| tagged_union_expression</p>

<p>tagged_union_expression ::=</p>

<p><span style='color:red'>tagged </span>member_identifier
[ expression ]</p>

<p>inside_expression ::= expression <span style='color:red'>inside
{ </span>open_range_list <span style='color:red'>}</span></p>

<p>value_range ::= expression</p>

<p>| <span style='color:red'>[ </span>expression <span
style='color:red'>: </span>expression <span style='color:red'>]</span></p>

<p>mintypmax_expression ::= expression</p>

<p>| expression <span style='color:red'>: </span>expression
<span style='color:red'>: </span>expression</p>

<p>module_path_conditional_expression ::=
module_path_expression <span style='color:red'>? </span>{
attribute_instance }</p>

<p>module_path_expression <span style='color:red'>: </span>module_path_expression</p>

<p>module_path_expression ::= module_path_primary</p>

<p>| unary_module_path_operator { attribute_instance }
module_path_primary</p>

<p>| module_path_expression binary_module_path_operator {
attribute_instance }</p>

<p>module_path_expression</p>

<p>| module_path_conditional_expression</p>

<p>module_path_mintypmax_expression ::= module_path_expression</p>

<p>| module_path_expression <span style='color:red'>: </span>module_path_expression
<span style='color:red'>: </span>module_path_expression</p>

<p>part_select_range ::= constant_range | indexed_range</p>

<p>indexed_range ::=</p>

<p>expression <span style='color:red'>+: </span>constant_expression</p>

<p>| expression <span style='color:red'>-: </span>constant_expression
genvar_expression ::= constant_expression</p>

 

<p>// A.8.4 Primaries</p>

<p>constant_primary ::= primary_literal</p>

<p>| ps_parameter_identifier constant_select</p>

<p>| specparam_identifier [ <span style='color:red'>[ </span>constant_range_expression
<span style='color:red'>] </span>]</p>

 

 

 

 

 

<p>| genvar_identifier<span style='color:blue;position:relative;
top:-4.0pt'>39</span></p>

<p>| formal_port_identifier constant_select</p>

<p>| [ package_scope | class_scope ] enum_identifier</p>

<p>| constant_concatenation [ <span style='color:red'>[ </span>constant_range_expression
<span style='color:red'>] </span>]</p>

<p>| constant_multiple_concatenation [ <span style='color:red'>[
</span>constant_range_expression <span style='color:red'>] </span>] |
constant_function_call</p>

<p>| constant_let_expression</p>

<p>| <span style='color:red'>( </span>constant_mintypmax_expression
<span style='color:red'>)</span></p>

<p>| constant_cast</p>

<p>| constant_assignment_pattern_expression</p>

<p>| type_reference<span style='color:blue;position:relative;
top:-4.0pt'>40 </span>| <span style='color:red'>null</span></p>

<p>module_path_primary ::= number</p>

<p>| identifier</p>

<p>| module_path_concatenation</p>

<p>| module_path_multiple_concatenation</p>

<p>| function_subroutine_call</p>

<p>| <span style='color:red'>( </span>module_path_mintypmax_expression
<span style='color:red'>)</span></p>

<p>primary ::= primary_literal</p>

<p>| [ class_qualifier | package_scope ]
hierarchical_identifier select</p>

<p>| empty_unpacked_array_concatenation</p>

<p>| concatenation [ <span style='color:red'>[ </span>range_expression
<span style='color:red'>] </span>]</p>

<p>| multiple_concatenation [ <span style='color:red'>[ </span>range_expression
<span style='color:red'>] </span>]</p>

<p>| function_subroutine_call</p>

<p>| let_expression</p>

<p>| <span style='color:red'>( </span>mintypmax_expression <span
style='color:red'>)</span></p>

<p>| cast</p>

<p>| assignment_pattern_expression</p>

<p>| streaming_concatenation</p>

<p>| sequence_method_call</p>

<p>| <span style='color:red'>this</span><span
style='color:blue;position:relative;top:-4.0pt'>41</span></p>

<p>| <span style='color:red'>$</span><span
style='color:blue;position:relative;top:-4.0pt'>42</span></p>

<p>| <span style='color:red'>null</span></p>

<p>class_qualifier := [ <span style='color:red'>local ::</span><span
style='color:blue;position:relative;top:-4.0pt'>43 </span>] [
implicit_class_handle <span style='color:red'>. </span>| class_scope ]</p>

<p>range_expression ::= expression</p>

<p>| part_select_range</p>

<p>primary_literal ::= number | time_literal |
unbased_unsized_literal | string_literal</p>

<p>time_literal<span style='color:blue;position:relative;
top:-4.0pt'>44 </span>::= unsigned_number time_unit</p>

<p>| fixed_point_number time_unit time_unit ::= <span
style='color:red'>s </span>| <span style='color:red'>ms </span>| <span
style='color:red'>us </span>| <span style='color:red'>ns </span>| <span
style='color:red'>ps </span>| <span style='color:red'>fs</span></p>

<p>implicit_class_handle<span style='color:blue;position:relative;
top:-4.0pt'>41 </span>::= <span style='color:red'>this </span>| <span
style='color:red'>super </span>| <span style='color:red'>this . super</span></p>

<p>bit_select ::= { <span style='color:red'>[ </span>expression
<span style='color:red'>] </span>}</p>

<p>select ::=</p>

<p>[ { <span style='color:red'>. </span>member_identifier
bit_select } <span style='color:red'>. </span>member_identifier ]
bit_select [ <span style='color:red'>[ </span>part_select_range <span
style='color:red'>] </span>]</p>

<p>       nonrange_select ::=</p>

 

 

 

 

 

<p>[ { <span style='color:red'>. </span>member_identifier
bit_select } <span style='color:red'>. </span>member_identifier ] bit_select</p>

<p>constant_bit_select ::= { <span style='color:red'>[ </span>constant_expression
<span style='color:red'>] </span>}</p>

<p>constant_select ::=</p>

<p>[ { <span style='color:red'>. </span>member_identifier
constant_bit_select } <span style='color:red'>. </span>member_identifier ]
constant_bit_select</p>

<p>[ <span style='color:red'>[ </span>constant_part_select_range
<span style='color:red'>] </span>] constant_cast ::=</p>

<p>casting_type<span style='color:red'>' (</span>constant_expression<span
style='color:red'>) </span>constant_let_expression ::= let_expression<span
style='color:blue;position:relative;top:-4.0pt'>45</span></p>

<p>cast ::=</p>

<p>casting_type<span style='color:red'>' (</span>expression<span
style='color:red'>)</span></p>

<p> // A.8.5 Expression left-side values</p>

<p>net_lvalue ::=</p>

<p>ps_or_hierarchical_net_identifier constant_select</p>

<p>| <span style='color:red'>{ </span>net_lvalue { <span
style='color:red'>, </span>net_lvalue } <span style='color:red'>}</span></p>

<p>| [ assignment_pattern_expression_type ]
assignment_pattern_net_lvalue</p>

<p>variable_lvalue ::=</p>

<p>[implicit_class_handle<span style='color:red'>. </span>|package_scope]hierarchical_variable_identifierselect<span
style='color:blue;position:relative;top:-4.0pt'>46</span></p>

<p>| <span style='color:red'>{ </span>variable_lvalue { <span
style='color:red'>, </span>variable_lvalue } <span style='color:red'>}</span></p>

<p>| [ assignment_pattern_expression_type ] assignment_pattern_variable_lvalue</p>

<p>| streaming_concatenation<span style='color:blue;position:
relative;top:-4.0pt'>47 </span>nonrange_variable_lvalue ::=</p>

<p>[ implicit_class_handle <span style='color:red'>. </span>|
package_scope ] hierarchical_variable_identifier nonrange_select  // A.8.6
Operators</p>

<p>unary_operator ::=</p>

<p><span style='color:red'>+ </span>| <span
style='color:red'>- </span>| <span style='color:red'>! </span>| <span
style='color:red'>~ </span>| <span style='color:red'>&amp; </span>| <span
style='color:red'>~&amp; </span>| <span style='color:red'>| </span>| <span
style='color:red'>~| </span>| <span style='color:red'>^ </span>| <span
style='color:red'>~^ </span>| <span style='color:red'>^~</span></p>

<p>binary_operator ::=</p>

<p><span style='color:red'>+ </span>| <span
style='color:red'>- </span>| <span style='color:red'>* </span>| <span
style='color:red'>/ </span>| <span style='color:red'>% </span>| <span
style='color:red'>== </span>| <span style='color:red'>!= </span>| <span
style='color:red'>=== </span>| <span style='color:red'>!== </span>| <span
style='color:red'>==? </span>| <span style='color:red'>!=? </span>| <span
style='color:red'>&amp;&amp; </span>| <span style='color:red'>|| </span>|
<span style='color:red'>**</span></p>

<p>| <span style='color:red'>&lt;</span>|<span
style='color:red'>&lt;=</span>|<span style='color:red'>&gt;</span>|<span
style='color:red'>&gt;=</span>|<span style='color:red'>&amp;</span>|<span
style='color:red'>|</span>|<span style='color:red'>^</span>|<span
style='color:red'>^~</span>|<span style='color:red'>~^</span>|<span
style='color:red'>&gt;&gt;</span>|<span style='color:red'>&lt;&lt;</span>|<span
style='color:red'>&gt;&gt;&gt;</span>|<span style='color:red'>&lt;&lt;&lt;
</span>| <span style='color:red'>-&gt;</span>|<span style='color:red'>&lt;-&gt;</span></p>

<p><span style='color:red'>  </span> inc_or_dec_operator
::= <span style='color:red'>++ </span>| <span style='color:red'>-- </span>unary_module_path_operator
::=</p>

<p><span style='color:red'>! </span>| <span
style='color:red'>~ </span>| <span style='color:red'>&amp; </span>| <span
style='color:red'>~&amp; </span>| <span style='color:red'>| </span>| <span
style='color:red'>~| </span>| <span style='color:red'>^ </span>| <span
style='color:red'>~^ </span>| <span style='color:red'>^~ </span>binary_module_path_operator
::=</p>

<p><span style='color:red'>== </span>| <span
style='color:red'>!= </span>| <span style='color:red'>&amp;&amp; </span>|
<span style='color:red'>|| </span>| <span style='color:red'>&amp; </span>|
<span style='color:red'>| </span>| <span style='color:red'>^ </span>| <span
style='color:red'>^~ </span>| <span style='color:red'>~^ </span> // A.8.7
Numbers</p>

<p>number ::= integral_number</p>

<p>| real_number</p>

<p>integral_number ::= decimal_number</p>

<p>| octal_number</p>

<p>| binary_number</p>

 

 

 

 

 

<p>| hex_number</p>

<p>decimal_number ::= unsigned_number</p>

<p>| [ size ] decimal_base unsigned_number</p>

<p>| [ size ] decimal_base x_digit { <span style='color:red'>_
</span>}</p>

<p>| [ size ] decimal_base z_digit { <span style='color:red'>_
</span>}</p>

<p>binary_number ::= [ size ] binary_base binary_value
octal_number ::= [ size ] octal_base octal_value hex_number ::= [ size ]
hex_base hex_value</p>

<p>sign ::= <span style='color:red'>+ </span>| <span
style='color:red'>-</span></p>

<p>size ::= non_zero_unsigned_number</p>

<p>non_zero_unsigned_number<span style='color:blue;position:
relative;top:-4.0pt'>33 </span>::= non_zero_decimal_digit { <span
style='color:red'>_ </span>| decimal_digit}</p>

<p>real_number<span style='color:blue;position:relative;
top:-4.0pt'>33 </span>::= fixed_point_number</p>

<p>| unsigned_number [ <span style='color:red'>. </span>unsigned_number
] exp [ sign ] unsigned_number fixed_point_number<span style='color:blue;
position:relative;top:-4.0pt'>33 </span>::= unsigned_number <span
style='color:red'>. </span>unsigned_number</p>

<p>exp ::= <span style='color:red'>e </span>| <span
style='color:red'>E</span></p>

<p>unsigned_number<span style='color:blue;position:relative;
top:-4.0pt'>33 </span>::= decimal_digit { <span style='color:red'>_ </span>|
decimal_digit } binary_value<span style='color:blue;position:relative;
top:-4.0pt'>33 </span>::= binary_digit { <span style='color:red'>_ </span>|
binary_digit } octal_value<span style='color:blue;position:relative;top:-4.0pt'>33
</span>::= octal_digit { <span style='color:red'>_ </span>| octal_digit }
hex_value<span style='color:blue;position:relative;top:-4.0pt'>33 </span>::=
hex_digit { <span style='color:red'>_ </span>| hex_digit }</p>

<p>decimal_base<span style='color:blue;position:relative;
top:-4.0pt'>33 </span>::= <span style='color:red'>'</span>[<span
style='color:red'>s</span>|<span style='color:red'>S</span>]<span
style='color:red'>d </span>| <span style='color:red'>'</span>[<span
style='color:red'>s</span>|<span style='color:red'>S</span>]<span
style='color:red'>D</span></p>

<p>binary_base<span style='color:blue;position:relative;
top:-4.0pt'>33 </span>::= <span style='color:red'>'</span>[<span
style='color:red'>s</span>|<span style='color:red'>S</span>]<span
style='color:red'>b </span>| <span style='color:red'>'</span>[<span
style='color:red'>s</span>|<span style='color:red'>S</span>]<span
style='color:red'>B</span></p>

<p>octal_base<span style='color:blue;position:relative;
top:-4.0pt'>33 </span>::= <span style='color:red'>'</span>[<span
style='color:red'>s</span>|<span style='color:red'>S</span>]<span
style='color:red'>o </span>| <span style='color:red'>'</span>[<span
style='color:red'>s</span>|<span style='color:red'>S</span>]<span
style='color:red'>O</span></p>

<p>hex_base<span style='color:blue;position:relative;
top:-4.0pt'>33 </span>::= <span style='color:red'>'</span>[<span
style='color:red'>s</span>|<span style='color:red'>S</span>]<span
style='color:red'>h </span>| <span style='color:red'>'</span>[<span
style='color:red'>s</span>|<span style='color:red'>S</span>]<span
style='color:red'>H</span></p>

<p>non_zero_decimal_digit ::= <span style='color:red'>1 </span>|
<span style='color:red'>2 </span>| <span style='color:red'>3 </span>| <span
style='color:red'>4 </span>| <span style='color:red'>5 </span>| <span
style='color:red'>6 </span>| <span style='color:red'>7 </span>| <span
style='color:red'>8 </span>| <span style='color:red'>9</span></p>

<p>decimal_digit ::= <span style='color:red'>0 </span>| <span
style='color:red'>1 </span>| <span style='color:red'>2 </span>| <span
style='color:red'>3 </span>| <span style='color:red'>4 </span>| <span
style='color:red'>5 </span>| <span style='color:red'>6 </span>| <span
style='color:red'>7 </span>| <span style='color:red'>8 </span>| <span
style='color:red'>9</span></p>

<p>binary_digit ::= x_digit | z_digit | <span style='color:
red'>0 </span>| <span style='color:red'>1</span></p>

<p>octal_digit ::= x_digit | z_digit | <span style='color:red'>0
</span>| <span style='color:red'>1 </span>| <span style='color:red'>2 </span>|
<span style='color:red'>3 </span>| <span style='color:red'>4 </span>| <span
style='color:red'>5 </span>| <span style='color:red'>6 </span>| <span
style='color:red'>7</span></p>

<p>hex_digit ::= x_digit | z_digit | <span style='color:red'>0
</span>| <span style='color:red'>1 </span>| <span style='color:red'>2 </span>|
<span style='color:red'>3 </span>| <span style='color:red'>4 </span>| <span
style='color:red'>5 </span>| <span style='color:red'>6 </span>| <span
style='color:red'>7 </span>| <span style='color:red'>8 </span>| <span
style='color:red'>9 </span>| <span style='color:red'>a </span>| <span
style='color:red'>b </span>| <span style='color:red'>c </span>| <span
style='color:red'>d </span>| <span style='color:red'>e </span>| <span
style='color:red'>f </span>| <span style='color:red'>A </span>| <span
style='color:red'>B </span>| <span style='color:red'>C </span>| <span
style='color:red'>D </span>| <span style='color:red'>E </span>| <span
style='color:red'>F </span>x_digit ::= <span style='color:red'>x </span>|
<span style='color:red'>X</span></p>

<p>z_digit ::= <span style='color:red'>z </span>| <span
style='color:red'>Z </span>| <span style='color:red'>?</span></p>

<p>unbased_unsized_literal ::= <span style='color:red'>'0 </span>|
<span style='color:red'>'1 </span>| <span style='color:red'>'</span>z_or_x
<span style='color:blue;position:relative;top:-4.0pt'>48 </span> </p>

<p>&nbsp;</p>

<p>// A.8.8 Strings</p>

<p>string_literal ::= <span style='color:red'>&quot; </span>{
Any_ASCII_Characters } <span style='color:red'>&quot;</span></p>

<p><span style='color:red'>      </span>       </p>

 

 

 

 

<p> // A.9 General  // A.9.1 Attributes</p>

<p>attribute_instance ::= <span style='color:red'>(* </span>attr_spec
{ <span style='color:red'>, </span>attr_spec } <span style='color:red'>*)
</span>attr_spec ::= attr_name [ <span style='color:red'>= </span>constant_expression
] attr_name ::= identifier</p>

<p> // A.9.2 Comments</p>

<p>comment ::= one_line_comment</p>

<p>| block_comment</p>

<p>one_line_comment ::= <span style='color:red'>// </span>comment_text
\n block_comment ::= <span style='color:red'>/* </span>comment_text <span
style='color:red'>*/ </span>comment_text ::= { Any_ASCII_character }</p>

<p> // A.9.3 Identifiers</p>

<p>array_identifier ::= identifier block_identifier ::=
identifier bin_identifier ::= identifier</p>

<p>c_identifier<span style='color:blue;position:relative;
top:-4.0pt'>49 </span>::= [ <span style='color:red'>a</span>-<span
style='color:red'>zA</span>-<span style='color:red'>Z_ </span>] { [ <span
style='color:red'>a</span>-<span style='color:red'>zA</span>-<span
style='color:red'>Z0</span>-<span style='color:red'>9_ </span>] }
cell_identifier ::= identifier</p>

<p>checker_identifier ::= identifier</p>

<p>class_identifier ::= identifier class_variable_identifier
::= variable_identifier clocking_identifier ::= identifier config_identifier
::= identifier</p>

<p>const_identifier ::= identifier</p>

<p>constraint_identifier ::= identifier covergroup_identifier
::= identifier covergroup_variable_identifier ::= variable_identifier
cover_point_identifier ::= identifier</p>

<p>cross_identifier ::= identifier</p>

<p>dynamic_array_variable_identifier ::= variable_identifier</p>

<p>enum_identifier ::= identifier</p>

<p>escaped_identifier ::= <span style='color:red'>\ </span>{any_printable_ASCII_character_except_white_space}
white_space formal_identifier ::= identifier</p>

<p>formal_port_identifier ::= identifier</p>

<p>function_identifier ::= identifier</p>

<p>generate_block_identifier ::= identifier</p>

<p>genvar_identifier ::= identifier</p>

<p>hierarchical_array_identifier ::= hierarchical_identifier</p>

 

 

<p>  </p>

 

 

<p>hierarchical_block_identifier ::= hierarchical_identifier
hierarchical_event_identifier ::= hierarchical_identifier</p>

<p>hierarchical_identifier ::= [ <span style='color:red'>$root
. </span>] { identifier constant_bit_select <span style='color:red'>. </span>}
identifier hierarchical_net_identifier ::= hierarchical_identifier
hierarchical_parameter_identifier ::= hierarchical_identifier
hierarchical_property_identifier ::= hierarchical_identifier
hierarchical_sequence_identifier ::= hierarchical_identifier
hierarchical_task_identifier ::= hierarchical_identifier</p>

<p>hierarchical_tf_identifier ::= hierarchical_identifier
hierarchical_variable_identifier ::= hierarchical_identifier</p>

<p>identifier ::= simple_identifier</p>

<p>| escaped_identifier index_variable_identifier ::=
identifier interface_identifier ::= identifier interface_instance_identifier
::= identifier inout_port_identifier ::= identifier input_port_identifier ::=
identifier instance_identifier ::= identifier library_identifier ::= identifier
member_identifier ::= identifier method_identifier ::= identifier
modport_identifier ::= identifier module_identifier ::= identifier
net_identifier ::= identifier net_type_identifier ::= identifier
output_port_identifier ::= identifier package_identifier ::= identifier</p>

<p>package_scope ::= package_identifier <span style='color:
red'>::</span></p>

<p>| <span style='color:red'>$unit ::</span></p>

<p>parameter_identifier ::= identifier</p>

<p>port_identifier ::= identifier</p>

<p>production_identifier ::= identifier</p>

<p>program_identifier ::= identifier</p>

<p>property_identifier ::= identifier</p>

<p>ps_class_identifier ::= [ package_scope ] class_identifier</p>

<p>ps_covergroup_identifier ::= [ package_scope ]
covergroup_identifier</p>

<p>ps_checker_identifier ::= [ package_scope ]
checker_identifier</p>

<p>ps_identifier ::= [ package_scope ] identifier</p>

<p>ps_or_hierarchical_array_identifier ::=</p>

<p>[ implicit_class_handle <span style='color:red'>. </span>|
class_scope | package_scope ] hierarchical_array_identifier</p>

<p>ps_or_hierarchical_net_identifier ::= [ package_scope ]
net_identifier | hierarchical_net_identifier ps_or_hierarchical_property_identifier
::=</p>

 

 

 

 

 

<p>[ package_scope ] property_identifier |
hierarchical_property_identifier</p>

<p>ps_or_hierarchical_sequence_identifier ::= [ package_scope ]
sequence_identifier</p>

<p>| hierarchical_sequence_identifier</p>

<p>ps_or_hierarchical_tf_identifier ::= [ package_scope ]
tf_identifier</p>

<p>| hierarchical_tf_identifier</p>

<p>ps_parameter_identifier ::=</p>

<p>[ package_scope | class_scope ] parameter_identifier</p>

<p>| { generate_block_identifier [ <span style='color:red'>[
</span>constant_expression <span style='color:red'>] </span>] <span
style='color:red'>. </span>} parameter_identifier</p>

<p>ps_type_identifier ::= [ <span style='color:red'>local
::</span><span style='color:blue;position:relative;top:-4.0pt'>43 </span>|
package_scope | class_scope ] type_identifier sequence_identifier ::=
identifier</p>

<p>signal_identifier ::= identifier</p>

<p>simple_identifier<span style='color:blue;position:relative;
top:-4.0pt'>49 </span>::= [ <span style='color:red'>a</span>-<span
style='color:red'>zA</span>-<span style='color:red'>Z_ </span>] { [ <span
style='color:red'>a</span>-<span style='color:red'>zA</span>-<span
style='color:red'>Z0</span>-<span style='color:red'>9_$ </span>] }
specparam_identifier ::= identifier</p>

<p>system_tf_identifier<span style='color:blue;position:relative;
top:-4.0pt'>50 </span>::= <span style='color:red'>$</span>[ <span
style='color:red'>a</span>-<span style='color:red'>zA</span>-<span
style='color:red'>Z0</span>-<span style='color:red'>9_$ </span>]{ [ <span
style='color:red'>a</span>-<span style='color:red'>zA</span>-<span
style='color:red'>Z0</span>-<span style='color:red'>9_$ </span>] }
task_identifier ::= identifier</p>

<p>tf_identifier ::= identifier</p>

<p>terminal_identifier ::= identifier</p>

<p>topmodule_identifier ::= identifier type_identifier ::=
identifier udp_identifier ::= identifier variable_identifier ::= identifier</p>

<p> // A.9.4 White space</p>

<p>white_space ::= space | tab | newline | eof</p>

<p> // A.10 Footnotes (normative)</p>


</body>
</html>
